<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · TaskGraphs.jl</title><link rel="canonical" href="https://kylejbrown17.github.io/TaskGraphs.jl/reference/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TaskGraphs.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../profiling/">Profiling</a></li><li><a class="tocitem" href="../library/">Core Types and Methods</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docs"><span>Docs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/kylejbrown17/TaskGraphs.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TaskGraphs.GADGET_EDGE_MULTIPLIER"><code>TaskGraphs.GADGET_EDGE_MULTIPLIER</code></a></li><li><a href="../library/#TaskGraphs.AStarSC"><code>TaskGraphs.AStarSC</code></a></li><li><a href="#TaskGraphs.AbstractPCTAPFSolver"><code>TaskGraphs.AbstractPCTAPFSolver</code></a></li><li><a href="../library/#TaskGraphs.AbstractPC_MAPF"><code>TaskGraphs.AbstractPC_MAPF</code></a></li><li><a href="../library/#TaskGraphs.AbstractPC_TAPF"><code>TaskGraphs.AbstractPC_TAPF</code></a></li><li><a href="../library/#TaskGraphs.AssignmentMILP"><code>TaskGraphs.AssignmentMILP</code></a></li><li><a href="../library/#TaskGraphs.BOT_AT"><code>TaskGraphs.BOT_AT</code></a></li><li><a href="#TaskGraphs.BOT_CARRY"><code>TaskGraphs.BOT_CARRY</code></a></li><li><a href="../library/#TaskGraphs.BOT_COLLECT"><code>TaskGraphs.BOT_COLLECT</code></a></li><li><a href="../library/#TaskGraphs.BOT_DEPOSIT"><code>TaskGraphs.BOT_DEPOSIT</code></a></li><li><a href="#TaskGraphs.BOT_GO"><code>TaskGraphs.BOT_GO</code></a></li><li><a href="#TaskGraphs.CLEAN_UP"><code>TaskGraphs.CLEAN_UP</code></a></li><li><a href="../library/#TaskGraphs.C_PC_MAPF"><code>TaskGraphs.C_PC_MAPF</code></a></li><li><a href="../library/#TaskGraphs.C_PC_TAPF"><code>TaskGraphs.C_PC_TAPF</code></a></li><li><a href="#TaskGraphs.CleanUpBot"><code>TaskGraphs.CleanUpBot</code></a></li><li><a href="../library/#TaskGraphs.ConstrainedMergeAndBalance"><code>TaskGraphs.ConstrainedMergeAndBalance</code></a></li><li><a href="#TaskGraphs.DeadRobot"><code>TaskGraphs.DeadRobot</code></a></li><li><a href="../library/#TaskGraphs.DeferUntilCompletion"><code>TaskGraphs.DeferUntilCompletion</code></a></li><li><a href="#TaskGraphs.DelayedRobot"><code>TaskGraphs.DelayedRobot</code></a></li><li><a href="#TaskGraphs.DroppedObject"><code>TaskGraphs.DroppedObject</code></a></li><li><a href="../library/#TaskGraphs.EnvState"><code>TaskGraphs.EnvState</code></a></li><li><a href="../library/#TaskGraphs.FullReplanner"><code>TaskGraphs.FullReplanner</code></a></li><li><a href="#TaskGraphs.GadgetGraph"><code>TaskGraphs.GadgetGraph</code></a></li><li><a href="../library/#TaskGraphs.GreedyAssignment"><code>TaskGraphs.GreedyAssignment</code></a></li><li><a href="../library/#TaskGraphs.ISPS"><code>TaskGraphs.ISPS</code></a></li><li><a href="#TaskGraphs.Intruder"><code>TaskGraphs.Intruder</code></a></li><li><a href="../library/#TaskGraphs.MergeAndBalance"><code>TaskGraphs.MergeAndBalance</code></a></li><li><a href="../library/#TaskGraphs.NBSSolver"><code>TaskGraphs.NBSSolver</code></a></li><li><a href="../library/#TaskGraphs.OBJECT_AT"><code>TaskGraphs.OBJECT_AT</code></a></li><li><a href="#TaskGraphs.OilSpill"><code>TaskGraphs.OilSpill</code></a></li><li><a href="../library/#TaskGraphs.OperatingSchedule"><code>TaskGraphs.OperatingSchedule</code></a></li><li><a href="#TaskGraphs.Operation"><code>TaskGraphs.Operation</code></a></li><li><a href="../library/#TaskGraphs.PC_MAPF"><code>TaskGraphs.PC_MAPF</code></a></li><li><a href="../library/#TaskGraphs.PC_TA"><code>TaskGraphs.PC_TA</code></a></li><li><a href="../library/#TaskGraphs.PC_TAPF"><code>TaskGraphs.PC_TAPF</code></a></li><li><a href="#TaskGraphs.PathSpec"><code>TaskGraphs.PathSpec</code></a></li><li><a href="#TaskGraphs.PrioritizedAStarSC"><code>TaskGraphs.PrioritizedAStarSC</code></a></li><li><a href="../library/#TaskGraphs.ProblemSpec"><code>TaskGraphs.ProblemSpec</code></a></li><li><a href="../library/#TaskGraphs.ProjectRequest"><code>TaskGraphs.ProjectRequest</code></a></li><li><a href="../library/#TaskGraphs.ProjectSpec"><code>TaskGraphs.ProjectSpec</code></a></li><li><a href="../library/#TaskGraphs.ReassignFreeRobots"><code>TaskGraphs.ReassignFreeRobots</code></a></li><li><a href="../library/#TaskGraphs.RepeatedPC_TAPF"><code>TaskGraphs.RepeatedPC_TAPF</code></a></li><li><a href="../library/#TaskGraphs.ReplannerConfig"><code>TaskGraphs.ReplannerConfig</code></a></li><li><a href="../library/#TaskGraphs.ReplannerModel"><code>TaskGraphs.ReplannerModel</code></a></li><li><a href="../library/#TaskGraphs.ReplannerWithBackup"><code>TaskGraphs.ReplannerWithBackup</code></a></li><li><a href="../library/#TaskGraphs.ReplanningProfilerCache"><code>TaskGraphs.ReplanningProfilerCache</code></a></li><li><a href="../library/#TaskGraphs.ScheduleNode"><code>TaskGraphs.ScheduleNode</code></a></li><li><a href="../library/#TaskGraphs.SearchEnv"><code>TaskGraphs.SearchEnv</code></a></li><li><a href="#TaskGraphs.SimpleRepeatedProblemDef"><code>TaskGraphs.SimpleRepeatedProblemDef</code></a></li><li><a href="#TaskGraphs.SimpleReplanningRequest"><code>TaskGraphs.SimpleReplanningRequest</code></a></li><li><a href="../library/#TaskGraphs.SparseAdjacencyMILP"><code>TaskGraphs.SparseAdjacencyMILP</code></a></li><li><a href="#TaskGraphs.StochasticProblem"><code>TaskGraphs.StochasticProblem</code></a></li><li><a href="../library/#TaskGraphs.TEAM_ACTION"><code>TaskGraphs.TEAM_ACTION</code></a></li><li><a href="../library/#TaskGraphs.TaskGraphsMILP"><code>TaskGraphs.TaskGraphsMILP</code></a></li><li><a href="../library/#TaskGraphs.TaskGraphsMILPSolver"><code>TaskGraphs.TaskGraphsMILPSolver</code></a></li><li><a href="../library/#TaskGraphs.TaskGraphsProblemLoader"><code>TaskGraphs.TaskGraphsProblemLoader</code></a></li><li><a href="#TaskGraphs.TeamAssignmentMILP"><code>TaskGraphs.TeamAssignmentMILP</code></a></li><li><a href="#TaskGraphs.UNDERTAKE"><code>TaskGraphs.UNDERTAKE</code></a></li><li><a href="#CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any,C_PC_MAPF,E,N,T,Int64}} where T where N&lt;:ConstraintTreeNode where E&lt;:SearchEnv"><code>CRCBS.build_env</code></a></li><li><a href="../library/#CRCBS.load_problem"><code>CRCBS.load_problem</code></a></li><li><a href="#CRCBS.load_problem-Tuple{TaskGraphsProblemLoader,Any,Any}"><code>CRCBS.load_problem</code></a></li><li><a href="#CRCBS.pibt_update_solution!-Tuple{Any,SearchEnv,Any}"><code>CRCBS.pibt_update_solution!</code></a></li><li><a href="../library/#CRCBS.run_profiling"><code>CRCBS.run_profiling</code></a></li><li><a href="#CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader,Any,Any}"><code>CRCBS.run_profiling</code></a></li><li><a href="#CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver,E}} where E&lt;:AbstractPC_TAPF"><code>CRCBS.solve!</code></a></li><li><a href="#JuMP.optimize!-Tuple{GreedyAssignment}"><code>JuMP.optimize!</code></a></li><li><a href="#TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}"><code>TaskGraphs.add_job_shop_constraints!</code></a></li><li><a href="#TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph,Any}"><code>TaskGraphs.add_movement_vtx!</code></a></li><li><a href="#TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule,Any}"><code>TaskGraphs.adj_mat_from_assignment_mat</code></a></li><li><a href="#TaskGraphs.align_with_predecessor-Tuple{Any,Any}"><code>TaskGraphs.align_with_predecessor</code></a></li><li><a href="#TaskGraphs.align_with_successor-Tuple{Any,Any}"><code>TaskGraphs.align_with_successor</code></a></li><li><a href="#TaskGraphs.backtrack_node-Tuple{OperatingSchedule,Int64}"><code>TaskGraphs.backtrack_node</code></a></li><li><a href="#TaskGraphs.break_assignments!-Tuple{OperatingSchedule,ProblemSpec}"><code>TaskGraphs.break_assignments!</code></a></li><li><a href="#TaskGraphs.check_object_id-Tuple{Any,Any}"><code>TaskGraphs.check_object_id</code></a></li><li><a href="#TaskGraphs.choose_random_object_sizes-Tuple{Any,Dict{Tuple{Int64,Int64},Float64}}"><code>TaskGraphs.choose_random_object_sizes</code></a></li><li><a href="#TaskGraphs.clear_default_optimizer_attributes!-Tuple{}"><code>TaskGraphs.clear_default_optimizer_attributes!</code></a></li><li><a href="#TaskGraphs.compute_lower_bound"><code>TaskGraphs.compute_lower_bound</code></a></li><li><a href="#TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,N}, Tuple{ISPS,AbstractPC_MAPF,N,SearchEnv}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.compute_route_plan!</code></a></li><li><a href="#TaskGraphs.construct_cost_model"><code>TaskGraphs.construct_cost_model</code></a></li><li><a href="#TaskGraphs.construct_heuristic_model"><code>TaskGraphs.construct_heuristic_model</code></a></li><li><a href="#TaskGraphs.construct_operation"><code>TaskGraphs.construct_operation</code></a></li><li><a href="#TaskGraphs.construct_partial_project_schedule"><code>TaskGraphs.construct_partial_project_schedule</code></a></li><li><a href="#TaskGraphs.construct_random_project_spec-Tuple{Int64,Array{OBJECT_AT,1},Array{OBJECT_AT,1}}"><code>TaskGraphs.construct_random_project_spec</code></a></li><li><a href="#TaskGraphs.construct_random_task_graphs_problem"><code>TaskGraphs.construct_random_task_graphs_problem</code></a></li><li><a href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a></li><li><a href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a></li><li><a href="#TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec,Array{Int64,1},Array{Int64,1},Array{Int64,1},Any}"><code>TaskGraphs.construct_task_graphs_problem</code></a></li><li><a href="#TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}"><code>TaskGraphs.convert_env_graph_to_undirected</code></a></li><li><a href="#TaskGraphs.default_milp_optimizer-Tuple{}"><code>TaskGraphs.default_milp_optimizer</code></a></li><li><a href="#TaskGraphs.default_optimizer_attributes-Tuple{}"><code>TaskGraphs.default_optimizer_attributes</code></a></li><li><a href="#TaskGraphs.evaluate_path_gap-Tuple{SearchEnv,Any,Any}"><code>TaskGraphs.evaluate_path_gap</code></a></li><li><a href="#TaskGraphs.exclude_solutions!-Tuple{JuMP.Model,Array{Int64,2}}"><code>TaskGraphs.exclude_solutions!</code></a></li><li><a href="#TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.fix_precutoff_nodes!</code></a></li><li><a href="#TaskGraphs.formulate_assignment_problem-Tuple{Any,Any}"><code>TaskGraphs.formulate_assignment_problem</code></a></li><li><a href="#TaskGraphs.formulate_big_milp"><code>TaskGraphs.formulate_big_milp</code></a></li><li><a href="#TaskGraphs.formulate_milp-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}"><code>TaskGraphs.formulate_milp</code></a></li><li><a href="../library/#TaskGraphs.formulate_milp"><code>TaskGraphs.formulate_milp</code></a></li><li><a href="#TaskGraphs.generate_path_spec-Tuple{ProblemSpec,Any}"><code>TaskGraphs.generate_path_spec</code></a></li><li><a href="#TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule,Any}"><code>TaskGraphs.get_active_and_fixed_vtxs</code></a></li><li><a href="#TaskGraphs.get_assignment_dict-Tuple{Any,Any,Any}"><code>TaskGraphs.get_assignment_dict</code></a></li><li><a href="#TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule,GraphUtils.ObjectID}"><code>TaskGraphs.get_delivery_task_vtxs</code></a></li><li><a href="#TaskGraphs.get_duration_vector-Tuple{ProjectSpec}"><code>TaskGraphs.get_duration_vector</code></a></li><li><a href="#TaskGraphs.get_env_snapshot-Tuple{SearchEnv,Any}"><code>TaskGraphs.get_env_snapshot</code></a></li><li><a href="#TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv,Any}"><code>TaskGraphs.get_next_node_matching_agent_id</code></a></li><li><a href="#TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv,Any}"><code>TaskGraphs.get_next_vtx_matching_agent_id</code></a></li><li><a href="#TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}"><code>TaskGraphs.get_node_start_and_end_times</code></a></li><li><a href="#TaskGraphs.get_objective_expr-Tuple{AssignmentMILP,MultiDeadlineCost{SumCost}}"><code>TaskGraphs.get_objective_expr</code></a></li><li><a href="#TaskGraphs.get_random_problem_instantiation-Tuple{Int64,Int64,Any,Any,Any}"><code>TaskGraphs.get_random_problem_instantiation</code></a></li><li><a href="#TaskGraphs.get_sF-Tuple{AssignmentMILP}"><code>TaskGraphs.get_sF</code></a></li><li><a href="#TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph,Any,Any}"><code>TaskGraphs.get_source_map</code></a></li><li><a href="#TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule,A}, Tuple{OperatingSchedule,A,Any}} where A&lt;:Union{GraphUtils.ActionID, GraphUtils.BotID}"><code>TaskGraphs.get_valid_robot_ids</code></a></li><li><a href="#TaskGraphs.handle_disturbance!"><code>TaskGraphs.handle_disturbance!</code></a></li><li><a href="#TaskGraphs.isolate_delivery_task_vtxs"><code>TaskGraphs.isolate_delivery_task_vtxs</code></a></li><li><a href="#TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A,Type{B}}} where B where A"><code>TaskGraphs.matches_node_type</code></a></li><li><a href="#TaskGraphs.pctapf_problem_1-Tuple{}"><code>TaskGraphs.pctapf_problem_1</code></a></li><li><a href="#TaskGraphs.pctapf_problem_10-Tuple{}"><code>TaskGraphs.pctapf_problem_10</code></a></li><li><a href="#TaskGraphs.pctapf_problem_11-Tuple{}"><code>TaskGraphs.pctapf_problem_11</code></a></li><li><a href="#TaskGraphs.pctapf_problem_12-Tuple{}"><code>TaskGraphs.pctapf_problem_12</code></a></li><li><a href="#TaskGraphs.pctapf_problem_13-Tuple{}"><code>TaskGraphs.pctapf_problem_13</code></a></li><li><a href="#TaskGraphs.pctapf_problem_2-Tuple{}"><code>TaskGraphs.pctapf_problem_2</code></a></li><li><a href="#TaskGraphs.pctapf_problem_3-Tuple{}"><code>TaskGraphs.pctapf_problem_3</code></a></li><li><a href="#TaskGraphs.pctapf_problem_4-Tuple{}"><code>TaskGraphs.pctapf_problem_4</code></a></li><li><a href="#TaskGraphs.pctapf_problem_5-Tuple{}"><code>TaskGraphs.pctapf_problem_5</code></a></li><li><a href="#TaskGraphs.pctapf_problem_6-Tuple{}"><code>TaskGraphs.pctapf_problem_6</code></a></li><li><a href="#TaskGraphs.pctapf_problem_7-Tuple{}"><code>TaskGraphs.pctapf_problem_7</code></a></li><li><a href="#TaskGraphs.pctapf_problem_8-Tuple{}"><code>TaskGraphs.pctapf_problem_8</code></a></li><li><a href="#TaskGraphs.pctapf_problem_9-Tuple{}"><code>TaskGraphs.pctapf_problem_9</code></a></li><li><a href="#TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,SearchEnv,N}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.plan_next_path!</code></a></li><li><a href="#TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC,AbstractPC_MAPF,SearchEnv,N,T,Int64}} where T where N&lt;:ConstraintTreeNode"><code>TaskGraphs.plan_path!</code></a></li><li><a href="#TaskGraphs.plan_route!-Tuple{Any,Any,Any}"><code>TaskGraphs.plan_route!</code></a></li><li><a href="#TaskGraphs.post_process_replanning_results!-Tuple{Any,Any}"><code>TaskGraphs.post_process_replanning_results!</code></a></li><li><a href="#TaskGraphs.preprocess_project_schedule-Tuple{Any}"><code>TaskGraphs.preprocess_project_schedule</code></a></li><li><a href="#TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P,Any}, Tuple{P,Any,Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.process_schedule</code></a></li><li><a href="#TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.prune_project_schedule</code></a></li><li><a href="#TaskGraphs.prune_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.prune_schedule</code></a></li><li><a href="#TaskGraphs.random_pctapf_def-Tuple{GraphUtils.GridFactoryEnvironment,Any}"><code>TaskGraphs.random_pctapf_def</code></a></li><li><a href="#TaskGraphs.random_pctapf_sequence-Tuple{GraphUtils.GridFactoryEnvironment,Any}"><code>TaskGraphs.random_pctapf_sequence</code></a></li><li><a href="#TaskGraphs.regenerate_path_specs!-Tuple{Any,Any}"><code>TaskGraphs.regenerate_path_specs!</code></a></li><li><a href="#TaskGraphs.replace_in_schedule!"><code>TaskGraphs.replace_in_schedule!</code></a></li><li><a href="#TaskGraphs.replanning_config_1-Tuple{}"><code>TaskGraphs.replanning_config_1</code></a></li><li><a href="#TaskGraphs.replanning_problem-NTuple{4,Any}"><code>TaskGraphs.replanning_problem</code></a></li><li><a href="#TaskGraphs.replanning_problem_3-Tuple{Any}"><code>TaskGraphs.replanning_problem_3</code></a></li><li><a href="#TaskGraphs.replanning_problem_4-Tuple{Any}"><code>TaskGraphs.replanning_problem_4</code></a></li><li><a href="#TaskGraphs.reset_cache!-Tuple{PlanningCache,OperatingSchedule}"><code>TaskGraphs.reset_cache!</code></a></li><li><a href="#TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N,Any}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.reset_route_plan!</code></a></li><li><a href="#TaskGraphs.resources_reserved-Tuple{Any}"><code>TaskGraphs.resources_reserved</code></a></li><li><a href="#TaskGraphs.robot_ids_match-Tuple{Any,Any}"><code>TaskGraphs.robot_ids_match</code></a></li><li><a href="#TaskGraphs.robot_tip_map"><code>TaskGraphs.robot_tip_map</code></a></li><li><a href="#TaskGraphs.select_next_edges-NTuple{4,Any}"><code>TaskGraphs.select_next_edges</code></a></li><li><a href="#TaskGraphs.set_default_milp_optimizer!-Tuple{Any}"><code>TaskGraphs.set_default_milp_optimizer!</code></a></li><li><a href="#TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair,Vararg{Any,N} where N}"><code>TaskGraphs.set_default_optimizer_attributes!</code></a></li><li><a href="#TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver,Any,Any}"><code>TaskGraphs.solve_assignment_problem!</code></a></li><li><a href="#TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P,P}, Tuple{P,P,Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.splice_schedules!</code></a></li><li><a href="#TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.split_active_vtxs!</code></a></li><li><a href="#TaskGraphs.split_node"><code>TaskGraphs.split_node</code></a></li><li><a href="#TaskGraphs.stitch_disjoint_node_sets!-NTuple{4,Any}"><code>TaskGraphs.stitch_disjoint_node_sets!</code></a></li><li><a href="#TaskGraphs.tighten_gaps!-Tuple{Any,AbstractPC_MAPF,SearchEnv,ConstraintTreeNode}"><code>TaskGraphs.tighten_gaps!</code></a></li><li><a href="#TaskGraphs.trim_route_plan-Tuple{Any,Any,Any}"><code>TaskGraphs.trim_route_plan</code></a></li><li><a href="#TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any,T,Any}} where T&lt;:TaskGraphsMILP"><code>TaskGraphs.update_assignment_problem!</code></a></li><li><a href="#TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any,SearchEnv,Int64,P}, Tuple{Any,SearchEnv,Int64,P,Any}} where P&lt;:Path"><code>TaskGraphs.update_env!</code></a></li><li><a href="#TaskGraphs.update_planning_cache!-Tuple{Any,SearchEnv,Int64,Path}"><code>TaskGraphs.update_planning_cache!</code></a></li><li><a href="#TaskGraphs.update_planning_cache!-Tuple{Any,Any}"><code>TaskGraphs.update_planning_cache!</code></a></li><li><a href="#TaskGraphs.update_project_schedule!-Tuple{Any,OperatingSchedule,Any,Any}"><code>TaskGraphs.update_project_schedule!</code></a></li><li><a href="#TaskGraphs.update_project_schedule!"><code>TaskGraphs.update_project_schedule!</code></a></li><li><a href="#TaskGraphs.update_route_plan!"><code>TaskGraphs.update_route_plan!</code></a></li><li><a href="#TaskGraphs.warmup"><code>TaskGraphs.warmup</code></a></li><li><a href="../library/#TaskGraphs.warmup"><code>TaskGraphs.warmup</code></a></li><li><a href="#TaskGraphs.write_problem"><code>TaskGraphs.write_problem</code></a></li><li><a href="../library/#TaskGraphs.write_problem"><code>TaskGraphs.write_problem</code></a></li></ul><h2 id="Docs"><a class="docs-heading-anchor" href="#Docs">Docs</a><a id="Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.GADGET_EDGE_MULTIPLIER" href="#TaskGraphs.GADGET_EDGE_MULTIPLIER"><code>TaskGraphs.GADGET_EDGE_MULTIPLIER</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">The number of edges in each &quot;gadget&quot; per original edge</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.AbstractPCTAPFSolver" href="#TaskGraphs.AbstractPCTAPFSolver"><code>TaskGraphs.AbstractPCTAPFSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractPCTAPFSolver</code></pre><p>Abstract type of which all PC-TAPF solvers must be concrete subtypes. All concrete solvers must implement the following interface for solving PC-TAPF problems:</p><ul><li><code>solution, cost = solve!(solver,problem_def)</code></li><li><code>check_runtime(solver)</code> should trigger an interrupt + early return if the   allowable runtime has been exceeded</li></ul><p>Also, we need a good Logger type for keeping track of thing like runtime, iterations, optimality gap (including upper and lower bound), etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.BOT_CARRY" href="#TaskGraphs.BOT_CARRY"><code>TaskGraphs.BOT_CARRY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BOT_CARRY &lt;: AbstractRobotAction</code></pre><p>Encodes the event &quot;robot <code>r</code> carries object <code>o</code> from <code>x1</code> to <code>x2</code>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.BOT_GO" href="#TaskGraphs.BOT_GO"><code>TaskGraphs.BOT_GO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BOT_GO &lt;: AbstractRobotAction</code></pre><p>Encodes the event &quot;robot <code>r</code> goes from <code>x1</code> to <code>x2</code>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.CLEAN_UP" href="#TaskGraphs.CLEAN_UP"><code>TaskGraphs.CLEAN_UP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CLEAN_UP &lt;: AbstractRobotAction</code></pre><p>Encodes the event &quot;robot <code>r</code> cleans up locations vtxs`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.CleanUpBot" href="#TaskGraphs.CleanUpBot"><code>TaskGraphs.CleanUpBot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CleanUpBot &lt;: AbstractRobotType</code></pre><p>A robot type for picking up dropped objects, cleaning up spills, and taking  care of dead robots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.DeadRobot" href="#TaskGraphs.DeadRobot"><code>TaskGraphs.DeadRobot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DeadRobot</code></pre><p>Robot <code>id</code> is frozen.</p><p>Effect:</p><ul><li>Freeze robot</li><li>Add &quot;no-go&quot; constraint to CBS/PIBT (how to do consistently? Perhaps place in   SearchEnv and add directly to PCCBSEnv) OR temporarily remove vertex from   graph</li><li>Set robot state to NULL state? How to avoid having CBS complain about   conflicts? Maybe set State to NULL State and place DeadRobotObject at the   collection site?</li><li>Dispatch CleanUpBot to collect frozen robot</li><li>When CleanUpBot returns to &quot;garage&quot;, regenerate frozen Robot&#39;s ROBOT_AT node   and valid state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.DelayedRobot" href="#TaskGraphs.DelayedRobot"><code>TaskGraphs.DelayedRobot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DelayedRobot</code></pre><p>Robot <code>id</code> is delayed by <code>dt</code> timesteps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.DroppedObject" href="#TaskGraphs.DroppedObject"><code>TaskGraphs.DroppedObject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DroppedObject</code></pre><p>Object <code>id</code> dropped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.GadgetGraph" href="#TaskGraphs.GadgetGraph"><code>TaskGraphs.GadgetGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GadgetGraph</code></pre><p>Represents a time-extended graph useful for MILP formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.Intruder" href="#TaskGraphs.Intruder"><code>TaskGraphs.Intruder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Intruder</code></pre><p>An intruder that begins at location <code>start_vtx</code> and follows policy <code>policy</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.OilSpill" href="#TaskGraphs.OilSpill"><code>TaskGraphs.OilSpill</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OilSpill</code></pre><p>An obstruction that affects vertices <code>vtxs</code> and edges <code>edges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.Operation" href="#TaskGraphs.Operation"><code>TaskGraphs.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Operation &lt;: AbstractPlanningPredicate</code></pre><p>A manufacturing operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.PathSpec" href="#TaskGraphs.PathSpec"><code>TaskGraphs.PathSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PathSpec</code></pre><p>Encodes information about the path that must be planned for a particular schedule node.</p><p>Fields:</p><ul><li><code>node_type::Symbol = :EMPTY</code></li><li><code>start_vtx::Int = -1</code></li><li><code>final_vtx::Int = -1</code></li><li><code>min_duration::Int = 0</code></li><li><code>agent_id::Int = -1</code></li><li><code>object_id::Int = -1</code></li><li><code>plan_path::Bool = true</code> - flag indicating whether a path must be planned.   For example, <code>Operation</code> nodes do not require any path planning.</li><li><code>tight::Bool = false</code> - if true, the path may not terminate prior to the   beginning of successors. If <code>tight == true</code>, local slack == 0. For example,   <code>GO</code> must not end before <code>COLLECT</code> can begin, because this would produce   empty time between planning phases.</li><li><code>static::Bool = false</code> - if true, the robot must remain in place for this   planning phase (e.g., COLLECT, DEPOSIT).</li><li><code>free::Bool = false</code> - if true, and if the node is a terminal node, the   planning must go on until all non-free nodes are completed.</li><li><code>fixed::Bool = false</code> - if true, do not plan path because it is already fixed.   Instead, retrieve the portion of the path directly from the pre-existing   solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.PrioritizedAStarSC" href="#TaskGraphs.PrioritizedAStarSC"><code>TaskGraphs.PrioritizedAStarSC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrioritizedAStarSC</code></pre><p>Low-level proritized path planner that employs Slack-and-Collision-Aware A*.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.SimpleRepeatedProblemDef" href="#TaskGraphs.SimpleRepeatedProblemDef"><code>TaskGraphs.SimpleRepeatedProblemDef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleRepeatedProblemDef</code></pre><p>Intermediate representation of a <code>RepeatedPC_TAPF</code> (useful for I/O)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.SimpleReplanningRequest" href="#TaskGraphs.SimpleReplanningRequest"><code>TaskGraphs.SimpleReplanningRequest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleReplanningRequest</code></pre><p>Intermediate representation of a <code>ProjectRequest</code> (useful for I/O)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.StochasticProblem" href="#TaskGraphs.StochasticProblem"><code>TaskGraphs.StochasticProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StochasticProblem{P&lt;:AbstractPC_TAPF}</code></pre><p>Defines a stochastic version of PC_TAPF, wherein different disturbances can cause unexpected problems in the factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.TeamAssignmentMILP" href="#TaskGraphs.TeamAssignmentMILP"><code>TaskGraphs.TeamAssignmentMILP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TeamAssignmentMILP</code></pre><p>***Not yet implemented.***</p><p>Eextend the assignment matrix formulation of <code>AssignmentMILP</code> to the &quot;team-forming&quot; case where robots must collaboratively transport some objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.UNDERTAKE" href="#TaskGraphs.UNDERTAKE"><code>TaskGraphs.UNDERTAKE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UNDERTAKE &lt;: AbstractRobotAction{CleanUpBot}</code></pre><p>Encodes the task of collecting, carrying, and depositing a dead robot</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/788b2c77c10c2160f4794a4d4b6b81a95a90940c/base/#L0-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any,C_PC_MAPF,E,N,T,Int64}} where T where N&lt;:ConstraintTreeNode where E&lt;:SearchEnv" href="#CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any,C_PC_MAPF,E,N,T,Int64}} where T where N&lt;:ConstraintTreeNode where E&lt;:SearchEnv"><code>CRCBS.build_env</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">For COLLABORATIVE transport problems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.load_problem-Tuple{TaskGraphsProblemLoader,Any,Any}" href="#CRCBS.load_problem-Tuple{TaskGraphsProblemLoader,Any,Any}"><code>CRCBS.load_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CRCBS.load_problem(loader::TaskGraphsProblemLoader,solver_config,prob_path)</code></pre><p>Currently only impemented for PC<em>TAPF and PC</em>TA</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.pibt_update_solution!-Tuple{Any,SearchEnv,Any}" href="#CRCBS.pibt_update_solution!-Tuple{Any,SearchEnv,Any}"><code>CRCBS.pibt_update_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CRCBS.pibt_update_solution!(solver,pc_mapf::PC_MAPF,solution::SearchEnv,cache)</code></pre><p>Overridden to update the SearchEnv</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader,Any,Any}" href="#CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader,Any,Any}"><code>CRCBS.run_profiling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">CRCBS.run_profiling(loader::TaskGraphsProblemLoader,solver_config,problem_dir)</code></pre><p>Run profiling with a <code>TaskGraphsProblemLoader</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver,E}} where E&lt;:AbstractPC_TAPF" href="#CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver,E}} where E&lt;:AbstractPC_TAPF"><code>CRCBS.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve!(solver, base_env::SearchEnv;kwargs...) where {A,P}</code></pre><p>Use the planner defined by <code>solver</code> to solve the PC-TAPF problem encoded by <code>base_env</code>. For solvers of type <code>NBSSolver</code>, the algorithm involves repeatedly solving an assignment problem followed by a route-planning problem. Within the generic <code>solve!</code> method it is possible to initialize an assignment problem (the type is not constrained) and then modify it via <code>update_assignment_problem!</code> prior to each new call to <code>solve_assignment_problem!</code>. This is the approach taken for various MILP-based assignment solvers. It is also possible to reconstruct the assignment problem from scratch within each call to <code>solve_assignment_problem!</code>.</p><p>Arguments:</p><ul><li>solver &lt;: AbstractPCTAPFSolver</li><li>base_env::SearchEnv : a PC-TAPF problem</li></ul><p>Outputs:</p><ul><li>best_env : a <code>SearchEnv</code> data structure that encodes a solution to the problem</li><li>cost : the cost of the solution encoded by <code>best_env</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimize!-Tuple{GreedyAssignment}" href="#JuMP.optimize!-Tuple{GreedyAssignment}"><code>JuMP.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>GreedyAssignment maintains three sets: The &quot;satisfied set&quot; <code>C</code>, the &quot;required incoming&quot; set <code>Ai</code>, and the &quot;available outgoing&quot; set <code>Ao</code>.</p><p>At each step, the algorithm identifies the nodes <code>v1 ∈ Ai</code> and <code>v2 ∈ Ao</code> with shortest &quot;distance&quot; (in the context of <code>OperatingSchedule</code>s, this distance refers to the duration of <code>v1</code> if an edge <code>v1 → v2</code> is added) and adds an edge between them. The distance corresponding to an ineligible edge is set to Inf.</p><p>After adding the edge, the algorithm sweeps through a topological ordering of the vertices and updates <code>C</code>, <code>Ai</code>, and <code>Ao</code>. In order for <code>v</code> to be placed in <code>C</code>, <code>v</code> must have enough incoming edges and all of <code>v</code>&#39;s predecessors must already be in <code>C</code>. In order to be added to <code>Ai</code>, <code>v</code> must have less than the required number of incoming edges and all of <code>v</code>&#39;s predecessors must already be in <code>C</code>. In order for <code>v</code> to be added to <code>Ao</code>, <code>v</code> must have less than the allowable number of outgoing edges, and must be in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}" href="#TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}"><code>TaskGraphs.add_job_shop_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_job_shop_constraints!(milp_model::AssignmentMILP,sched::OperatingSchedule,spec::ProblemSpec) #,model::JuMP.Model)</code></pre><p>After an <code>AssignmentMILP</code> has been optimized, add in any edges that result from an active ``job shop&#39;&#39; constraint (where two robots require the same resource).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph,Any}" href="#TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph,Any}"><code>TaskGraphs.add_movement_vtx!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add_movement_vtx!</code></pre><p>Flags a vertex of the gadget graph as corresponding to a non-&quot;wait&quot; edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule,Any}" href="#TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule,Any}"><code>TaskGraphs.adj_mat_from_assignment_mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">adj_mat_from_assignment_mat(sched,assignment_matrix)</code></pre><p>Compute an adjacency matrix from an assignment matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.align_with_predecessor-Tuple{Any,Any}" href="#TaskGraphs.align_with_predecessor-Tuple{Any,Any}"><code>TaskGraphs.align_with_predecessor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">align_with_predecessor(node,succ)</code></pre><p>Modifies a node to match the information encoded by its predecessor. This is how e.g., robot ids are propagated through an existing operating schedule after assignments (or re-assignments) have been made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.align_with_successor-Tuple{Any,Any}" href="#TaskGraphs.align_with_successor-Tuple{Any,Any}"><code>TaskGraphs.align_with_successor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">align_with_successor(node,succ)</code></pre><p>Modifies a node to match the information encoded by its successor. This is how e.g., robot ids are propagated through an existing operating schedule after assignments (or re-assignments) have been made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.backtrack_node-Tuple{OperatingSchedule,Int64}" href="#TaskGraphs.backtrack_node-Tuple{OperatingSchedule,Int64}"><code>TaskGraphs.backtrack_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`backtrack_node(sched::OperatingSchedule,v::Int)`</code></pre><p>Find the closest ancestor of <code>v</code> with overlapping <code>RobotID</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.break_assignments!-Tuple{OperatingSchedule,ProblemSpec}" href="#TaskGraphs.break_assignments!-Tuple{OperatingSchedule,ProblemSpec}"><code>TaskGraphs.break_assignments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">break_assignments!(sched::OperatingSchedule,problem_spec::ProblemSpec)</code></pre><p>Break all assignments that are eligible for replanning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.check_object_id-Tuple{Any,Any}" href="#TaskGraphs.check_object_id-Tuple{Any,Any}"><code>TaskGraphs.check_object_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Check if a node is associated with objectid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.choose_random_object_sizes-Tuple{Any,Dict{Tuple{Int64,Int64},Float64}}" href="#TaskGraphs.choose_random_object_sizes-Tuple{Any,Dict{Tuple{Int64,Int64},Float64}}"><code>TaskGraphs.choose_random_object_sizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Tool for randomly selecting how many robots (and in what configuration)
    should deliver each task.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.clear_default_optimizer_attributes!-Tuple{}" href="#TaskGraphs.clear_default_optimizer_attributes!-Tuple{}"><code>TaskGraphs.clear_default_optimizer_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clear_default_optimizer_attributes!()</code></pre><p>Clear the default optimizer attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.compute_lower_bound" href="#TaskGraphs.compute_lower_bound"><code>TaskGraphs.compute_lower_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">compute_lower_bound(env,[starts,assigned,dist_mtx,pairs])</code></pre><p>Computes a lower bound on makespan for <code>sched::OperatingSchedule</code> by assuming     that any robot can be simultaneously assigned to multiple tasks.</p><p>Args:</p><ul><li><code>env</code>      SearchEnv</li><li><code>starts</code>   the set of vertices whose outgoing edges are available</li><li><code>assigned</code> the set of vertices whose incoming edges are already assigned</li><li><code>dist_mtx</code> encodes the cost of each edge v -&gt; vp as <code>dist_mtx[v,vp]</code></li><li><code>pairs</code>    specifies eligible edges</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,N}, Tuple{ISPS,AbstractPC_MAPF,N,SearchEnv}} where N&lt;:ConstraintTreeNode" href="#TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,N}, Tuple{ISPS,AbstractPC_MAPF,N,SearchEnv}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.compute_route_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">compute_route_plan!</code></pre><p>Computes all paths specified by the project schedule and updates the solution in the ConstraintTreeNode::node accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_cost_model" href="#TaskGraphs.construct_cost_model"><code>TaskGraphs.construct_cost_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">construct_cost_model(solver::AStarSC, args...;kwargs...)</code></pre><p>Defines the cost model used by Slack- and Collision-aware A*. This particular setting of cost model is crucial for good performance of A_star, because it encourages depth first search. If we were to replace terms 3-5 with SumOfTravelTime(), we would get worst-case exponentially slow breadth-first search!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_heuristic_model" href="#TaskGraphs.construct_heuristic_model"><code>TaskGraphs.construct_heuristic_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">construct_heuristic_model(solver,env_graph;kwargs...)</code></pre><p>Construct the heuristic model to be used by solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_operation" href="#TaskGraphs.construct_operation"><code>TaskGraphs.construct_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">construct_operation(spec::ProjectSpec, station_id, input_ids, output_ids, Δt, id=get_unique_operation_id())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_partial_project_schedule" href="#TaskGraphs.construct_partial_project_schedule"><code>TaskGraphs.construct_partial_project_schedule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">construct_partial_project_schedule</code></pre><p>Constructs a partial project graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_random_project_spec-Tuple{Int64,Array{OBJECT_AT,1},Array{OBJECT_AT,1}}" href="#TaskGraphs.construct_random_project_spec-Tuple{Int64,Array{OBJECT_AT,1},Array{OBJECT_AT,1}}"><code>TaskGraphs.construct_random_project_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_random_project_spec(M::Int;max_children=1)

Inputs:
    `M` - number of objects involved in the operation
    `max_parents` - determines the max number of inputs to any operation
    `depth_bias` ∈ [0,1] - hyperparameter for tuning depth.
        If `depth_bias` == 1.0, the project_spec graph will always be depth
        balanced (all paths through the tree will be of the same length).
        For `depth_bias` == 0.0, the graph will be as &quot;strung out&quot; as
        possible.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_random_task_graphs_problem" href="#TaskGraphs.construct_random_task_graphs_problem"><code>TaskGraphs.construct_random_task_graphs_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">`construct_randomd_task_graphs_problem`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_search_env" href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function construct_search_env(solver, env::SearchEnv, ... )</code></pre><p>Construct a new SearchEnv, with cost<em>model and heuristic</em>model defined by the  solver type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_search_env" href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">construct_search_env(solver,schedule,env,...)</code></pre><p>Constructs a new search env by combining the new <code>schedule</code> with the pre- existing <code>get_route_plan(env)</code>. This involves constructing a new cost function that reflects the new schedule structure. TODO: Carry over information about <code>get_cache(search_env)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec,Array{Int64,1},Array{Int64,1},Array{Int64,1},Any}" href="#TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec,Array{Int64,1},Array{Int64,1},Array{Int64,1},Any}"><code>TaskGraphs.construct_task_graphs_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`construct_task_graphs_problem`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}" href="#TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}"><code>TaskGraphs.convert_env_graph_to_undirected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">It is necessary to convert the env graph to an undirected graph because the
gadget is based on undirected edges. Self-edges also need to be removed, as
these are already accounted for in the gadget.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.default_milp_optimizer-Tuple{}" href="#TaskGraphs.default_milp_optimizer-Tuple{}"><code>TaskGraphs.default_milp_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">default_milp_optimizer()</code></pre><p>Returns the black box optimizer to be use when formulating JuMP models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.default_optimizer_attributes-Tuple{}" href="#TaskGraphs.default_optimizer_attributes-Tuple{}"><code>TaskGraphs.default_optimizer_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">default_optimizer_attributes()</code></pre><p>Return a dictionary of default optimizer attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.evaluate_path_gap-Tuple{SearchEnv,Any,Any}" href="#TaskGraphs.evaluate_path_gap-Tuple{SearchEnv,Any,Any}"><code>TaskGraphs.evaluate_path_gap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">evaluate_path_gap(search_env::SearchEnv,path,v)</code></pre><p>Returns the gap between a path&#39;s length and it&#39;s expected length (based on times stored in <code>get_cache(env).t0</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.exclude_solutions!-Tuple{JuMP.Model,Array{Int64,2}}" href="#TaskGraphs.exclude_solutions!-Tuple{JuMP.Model,Array{Int64,2}}"><code>TaskGraphs.exclude_solutions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exclude_solutions!(model::JuMP.Model,forbidden_solutions::Vector{Matrix{Int}})</code></pre><p>Adds constraints to model such that the solution may not match any solution contained in forbidden<em>solutions. Assumes that the model contains a variable container called X whose entries are binary and whose dimensions are identical to the dimensions of each solution in forbidden</em>solutions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule,ProblemSpec,Any}" href="#TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.fix_precutoff_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fix_precutoff_nodes!(sched::OperatingSchedule,
    problem_spec::ProblemSpec,t)</code></pre><p>Identify all nodes that end before the cutoff time, and change their path spec     so that the route planner will not actually plan a path for them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.formulate_assignment_problem-Tuple{Any,Any}" href="#TaskGraphs.formulate_assignment_problem-Tuple{Any,Any}"><code>TaskGraphs.formulate_assignment_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">formulate_assignment_problem(solver,prob;</code></pre><p>Returns an assignment problem instance that can be updated (as opposed to being reconstructed from scratch) on each call to <code>update_assignment_problem!</code> prior to being resolved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.formulate_big_milp" href="#TaskGraphs.formulate_big_milp"><code>TaskGraphs.formulate_big_milp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">formulate_big_milp</code></pre><p>Formulate a PCTAPF problem as a giant network flow MILP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.formulate_milp-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}" href="#TaskGraphs.formulate_milp-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}"><code>TaskGraphs.formulate_milp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">formulate_milp(milp_model::AssignmentMILP,sched,problem_spec;kwargs...)</code></pre><p>Express the TaskGraphs assignment problem as an <code>AssignmentMILP</code> using the JuMP optimization framework.</p><p>Inputs:     milp<em>model::T &lt;: TaskGraphsMILP : a milp model that determines how the         sequential task assignment problem is modeled. Current options are         <code>AssignmentMILP</code>, <code>SparseAdjacencyMILP</code> and <code>GreedyAssignment</code>.     sched::OperatingSchedule : a partial operating schedule, where         some or all assignment edges may be missing.     problem</em>spec::ProblemSpec : encodes the distance matrix and other         information about the problem.</p><p>Keyword Args:     <code>optimizer</code> - a JuMP optimizer (e.g., Gurobi.optimizer)     <code>cost_model=MakeSpan</code> - optimization objective, currently either <code>MakeSpan</code>         or <code>SumOfMakeSpans</code>. Defaults to the cost<em>model associated with         `problem</em>spec<code>Outputs:</code>model::AssignmentMILP` - an instantiated optimization problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.generate_path_spec-Tuple{ProblemSpec,Any}" href="#TaskGraphs.generate_path_spec-Tuple{ProblemSpec,Any}"><code>TaskGraphs.generate_path_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generate_path_spec(spec,node)</code></pre><p>Generates a <code>PathSpec</code> struct that encodes information about the path to be planned for <code>node</code>.</p><p>Arguments:</p><ul><li>spec::ProblemSpec</li><li>node::T &lt;: AbstractPlanningPredicate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule,Any}" href="#TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule,Any}"><code>TaskGraphs.get_active_and_fixed_vtxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_active_and_fixed_vtxs(sched::OperatingSchedule,t)</code></pre><p>&quot;active&quot; vertices &quot;straddle&quot; the query time t &quot;fixed&quot; vertices finish before the query time t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_assignment_dict-Tuple{Any,Any,Any}" href="#TaskGraphs.get_assignment_dict-Tuple{Any,Any,Any}"><code>TaskGraphs.get_assignment_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_assignment_dict(assignment_matrix,N,M)</code></pre><p>Returns dictionary that maps each robot id to a sequence of tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule,GraphUtils.ObjectID}" href="#TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule,GraphUtils.ObjectID}"><code>TaskGraphs.get_delivery_task_vtxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_delivery_task_vtxs(sched::OperatingSchedule,o::ObjectID)</code></pre><p>Return all vertices that correspond to the delivery task (<code>COLLECT</code> → <code>CARRY</code> → <code>DEPOSIT</code>) of object <code>o</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_duration_vector-Tuple{ProjectSpec}" href="#TaskGraphs.get_duration_vector-Tuple{ProjectSpec}"><code>TaskGraphs.get_duration_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_duration_vector(spec::ProjectSpec)</code></pre><p>Return a vector <code>Δt</code> such that <code>Δt[i]</code> is the amount of time that must elapse  before object <code>i</code> can be picked up after its parent operation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_env_snapshot-Tuple{SearchEnv,Any}" href="#TaskGraphs.get_env_snapshot-Tuple{SearchEnv,Any}"><code>TaskGraphs.get_env_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_env_snapshot(route_plan::S,t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv,Any}" href="#TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv,Any}"><code>TaskGraphs.get_next_node_matching_agent_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_next_node_matching_agent_id(schedule,cache,agent_id)</code></pre><p>Return the node_id of the active node assigned to an agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv,Any}" href="#TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv,Any}"><code>TaskGraphs.get_next_vtx_matching_agent_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_next_vtx_matching_agent_id(schedule,cache,agent_id)</code></pre><p>Return the node_id of the active node assigned to an agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}" href="#TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}"><code>TaskGraphs.get_node_start_and_end_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_start_and_end_maps(sched,cache,default=0)</code></pre><p>Return dictionaries mapping each node id in schedule to its start and end time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_objective_expr-Tuple{AssignmentMILP,MultiDeadlineCost{SumCost}}" href="#TaskGraphs.get_objective_expr-Tuple{AssignmentMILP,MultiDeadlineCost{SumCost}}"><code>TaskGraphs.get_objective_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_objective_expr</code></pre><p>Helper for setting the objective function for a milp model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_random_problem_instantiation-Tuple{Int64,Int64,Any,Any,Any}" href="#TaskGraphs.get_random_problem_instantiation-Tuple{Int64,Int64,Any,Any,Any}"><code>TaskGraphs.get_random_problem_instantiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`get_random_problem_instantiation`

Args:
- `N`: number of robots
- `M`: number of delivery tasks
- `robot_zones`: list of possible start locations for robots
- `pickup_zones`: list of possible start locations for objects
- `dropoff_zones`: list of possible destinations for objects</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_sF-Tuple{AssignmentMILP}" href="#TaskGraphs.get_sF-Tuple{AssignmentMILP}"><code>TaskGraphs.get_sF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_sF(milp_model::AssignmentMILP)</code></pre><p>Return an a vector of final object locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph,Any,Any}" href="#TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph,Any,Any}"><code>TaskGraphs.get_source_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Return a source map such that source_map[v][t] points to the corresponding
vertex in the gadget graph.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule,A}, Tuple{OperatingSchedule,A,Any}} where A&lt;:Union{GraphUtils.ActionID, GraphUtils.BotID}" href="#TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule,A}, Tuple{OperatingSchedule,A,Any}} where A&lt;:Union{GraphUtils.ActionID, GraphUtils.BotID}"><code>TaskGraphs.get_valid_robot_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_valid_robot_ids(sched::OperatingSchedule,node_id::AbstractID)</code></pre><p>Returns vector of all robot ids associated with the schedule node referenced by node_id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.handle_disturbance!" href="#TaskGraphs.handle_disturbance!"><code>TaskGraphs.handle_disturbance!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">handle_disturbance!(solver,prob,env,d::DroppedObject,t,env_state=get_env_state(env,t))</code></pre><p>Returns a new <code>SearchEnv</code> with a modified <code>OperatingSchedule</code>. The new schedule replaces the previous delivery task (<code>OBJECT_AT(o,old_x)</code> → <code>COLLECT</code> → <code>CARRY</code> → <code>DEPOSIT</code>) with a new <code>CleanUpBot</code> delivery task (<code>OBJECT_AT(o,new_x)</code> → <code>CUB_COLLECT</code> → <code>CUB_CARRY</code> → <code>CUB_DEPOSIT</code>). It is assumed that the time <code>t</code> corresponds to a moment when the object referred to by <code>d.id</code> is being <code>CARRIED</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.isolate_delivery_task_vtxs" href="#TaskGraphs.isolate_delivery_task_vtxs"><code>TaskGraphs.isolate_delivery_task_vtxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isolate_delivery_task_vtxs(sched,o,vtxs=get_delivery_task_vtxs(sched,o))</code></pre><p>Returns:</p><ul><li>incoming: a set of all incoming Action ScheduleNodes</li><li>outgoing: a set of all outgoing Action ScheduleNodes</li><li>op: the target Operation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A,Type{B}}} where B where A" href="#TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A,Type{B}}} where B where A"><code>TaskGraphs.matches_node_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">matches_node_type(::A,::Type{B}) where {A&lt;:AbstractPlanningPredicate,B}</code></pre><p>Returns true if {A &lt;: B}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_1-Tuple{}" href="#TaskGraphs.pctapf_problem_1-Tuple{}"><code>TaskGraphs.pctapf_problem_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_1</code></pre><p>Optimal MakeSpan = 5 Optimal SumOfMakeSpans = 5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_10-Tuple{}" href="#TaskGraphs.pctapf_problem_10-Tuple{}"><code>TaskGraphs.pctapf_problem_10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_10(;cost_function=MakeSpan(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0,0,0],Δt_deposit=[0,0,0,0,0,0])</code></pre><p>Motivation for backtracking in ISPS The makespan optimal solution is T = 8. However, the optimistic schedule will always prioritize task route planning for tasks 1,2, and 3 before 4. This leads to a double delay that will not be caught without backtracking in ISPS. Hence, the solver will return a solution with T = 9.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_11-Tuple{}" href="#TaskGraphs.pctapf_problem_11-Tuple{}"><code>TaskGraphs.pctapf_problem_11</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_11</code></pre><p>Requires collaborative transport: Robots 1 and 2 transport object 1 while robot 3 transports object 2. Robot 3 will need to move over to let the other robots pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_12-Tuple{}" href="#TaskGraphs.pctapf_problem_12-Tuple{}"><code>TaskGraphs.pctapf_problem_12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_12(;</code></pre><p>Robot 1 will plan a path first, but then that path will need to be extended by one time step because robot 2 will get delayed by robot 3, which is on the critical path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_13-Tuple{}" href="#TaskGraphs.pctapf_problem_13-Tuple{}"><code>TaskGraphs.pctapf_problem_13</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_13</code></pre><p>Same as <code>pctapf_problem_12</code>, except that there is a 4th robot who must collect  object 1 with robot 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_2-Tuple{}" href="#TaskGraphs.pctapf_problem_2-Tuple{}"><code>TaskGraphs.pctapf_problem_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_2(;cost_function=SumOfMakeSpans(),verbose=false)</code></pre><p>In this problem robot 1 will first do [1-9-17], then [17-21-35] robot 2 will do [4-12-32]. The key thing is that robot 1 will need to wait until robot 2 is finished before robot 1 can do its second task.</p><p>Optimal paths: Optimal MakeSpan = 8 Optimal SumOfMakeSpans = 8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_3-Tuple{}" href="#TaskGraphs.pctapf_problem_3-Tuple{}"><code>TaskGraphs.pctapf_problem_3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_3(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0],Δt_deposit=[0,0,0,0])</code></pre><p>In this problem robot 2 will need to yield to let robot 1 through. First operation:     robot 1 does [2-2-30] Second operation:     robot 1 does [30-30-32]     robot 2 does [5-7-8] Third operation:     robot 2 does [8-12-16]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_4-Tuple{}" href="#TaskGraphs.pctapf_problem_4-Tuple{}"><code>TaskGraphs.pctapf_problem_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_4(;cost_function=SumOfMakeSpans(),verbose=false)</code></pre><p>In this problem the cost of the task assignment problem is lower than the true cost (which requires that one of the robots is delayed by a single time step) First operation:     robot 1 does [2-2-8]     robot 2 does [4-4-6]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_5-Tuple{}" href="#TaskGraphs.pctapf_problem_5-Tuple{}"><code>TaskGraphs.pctapf_problem_5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_5(;cost_function=SumOfMakeSpans(),verbose=false)</code></pre><p>In this problem the robots try to pass through each other in such a way that an edge conflict is generated.</p><p>First operation:     robot 1 does [3-11]     robot 2 does [15-7]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_6-Tuple{}" href="#TaskGraphs.pctapf_problem_6-Tuple{}"><code>TaskGraphs.pctapf_problem_6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_6(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=1,Δt_collect=[0,0,0],Δt_deposit=[0,0,0])</code></pre><p>Identical to <code>pctapf_problem_2</code>, but process time is non-zero. In this problem robot 1 will first do [1-5-9], then [9-13-17] robot 2 will do [4-8-32]. The key thing is that robot 1 will need to wait until robot 2 is finished before robot 1 can do its second task</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_7-Tuple{}" href="#TaskGraphs.pctapf_problem_7-Tuple{}"><code>TaskGraphs.pctapf_problem_7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_7(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,4,0],Δt_deposit=[0,0,0])</code></pre><p>Robot 2 will have to sit and wait at the pickup station, meaning that robot 1  will have to go around if robot 2 is on the critical path</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_8-Tuple{}" href="#TaskGraphs.pctapf_problem_8-Tuple{}"><code>TaskGraphs.pctapf_problem_8</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_8(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0],Δt_deposit=[0,0,0,0])</code></pre><p>Two-headed project. Robot 1 does the first half of the first head, and robot 2 handles the first half of the second head, and then they swap. Optimal MakeSpan = 8 Optimal SumOfMakeSpans = 16</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_9-Tuple{}" href="#TaskGraphs.pctapf_problem_9-Tuple{}"><code>TaskGraphs.pctapf_problem_9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pctapf_problem_9(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0],Δt_deposit=[0,0])</code></pre><p>Project with station-sharing. Station 5 needs to accessed by both robots for  picking up their objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,SearchEnv,N}} where N&lt;:ConstraintTreeNode" href="#TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,SearchEnv,N}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.plan_next_path!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`plan_next_path`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC,AbstractPC_MAPF,SearchEnv,N,T,Int64}} where T where N&lt;:ConstraintTreeNode" href="#TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC,AbstractPC_MAPF,SearchEnv,N,T,Int64}} where T where N&lt;:ConstraintTreeNode"><code>TaskGraphs.plan_path!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plan_path!

Computes next path specified by the project schedule and updates the
solution in the ConstraintTreeNode::node accordingly.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.plan_route!-Tuple{Any,Any,Any}" href="#TaskGraphs.plan_route!-Tuple{Any,Any,Any}"><code>TaskGraphs.plan_route!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plan_route!</code></pre><p>Compute a route plan that corresponds to the OperatingSchedule. Arguments:</p><ul><li>solver</li><li>schedule</li><li>search_env</li></ul><p>Outputs:</p><ul><li>A <code>SearchEnv</code> the contains a valid solution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.post_process_replanning_results!-Tuple{Any,Any}" href="#TaskGraphs.post_process_replanning_results!-Tuple{Any,Any}"><code>TaskGraphs.post_process_replanning_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">add start_time, completion_time, and makespan for each stage</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.preprocess_project_schedule-Tuple{Any}" href="#TaskGraphs.preprocess_project_schedule-Tuple{Any}"><code>TaskGraphs.preprocess_project_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preprocess_project_schedule(sched)</code></pre><p>Returns information about the eligible and required successors and predecessors of nodes in <code>sched</code></p><p>Arguments:</p><ul><li><code>sched::OperatingSchedule</code></li></ul><p>Outputs:</p><ul><li>missing_successors</li><li>missing_predecessors</li><li>n<em>eligible</em>successors</li><li>n<em>eligible</em>predecessors</li><li>n<em>required</em>successors</li><li>n<em>required</em>predecessors</li><li>upstream_vertices</li><li>non<em>upstream</em>vertices</li></ul><p>TODO: OBJECT<em>AT nodes should always have the properties that `indegree(G,v) == n</em>required<em>predecessors(v) == n</em>eligible<em>predecessors(v)<code></code>outdegree(G,v) == n</em>required<em>successors(v) == n</em>eligible_successors(v)` Not sure if this is currently the case. UPDATE: I believe this has already been     addressed by making each object come from an initial operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P,Any}, Tuple{P,Any,Any}} where P&lt;:OperatingSchedule" href="#TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P,Any}, Tuple{P,Any,Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.process_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">process_schedule(schedule::P) where {P&lt;:OperatingSchedule}</code></pre><p>Compute the optimistic start and end times, along with the slack associated with each vertex in the <code>schedule</code>. Slack for each vertex is represented as a vector in order to handle multi-headed projects.</p><p>Args:</p><ul><li>schedule::OperatingSchedule</li><li>[OPTIONAL] t0::Vector{Int}: default = zeros(Int,nv(schedule))</li><li>[OPTIONAL] tF::Vector{Int}: default = zeros(Int,nv(schedule))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}" href="#TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.prune_project_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`prune_project_schedule`</code></pre><p>Remove all vertices that have already been completed. The idea is to identify all <code>Operation</code>s that are completed before <code>t</code>, remove all nodes upstream of them (except for ROBOT<em>AT nodes), and create new edges between the ROBOT</em>AT nodes and their first GO assignments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.prune_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}" href="#TaskGraphs.prune_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.prune_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">prune_schedule(sched::OperatingSchedule,
    problem_spec::ProblemSpec,t)

remove nodes that don&#39;t need to be kept around any longer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.random_pctapf_def-Tuple{GraphUtils.GridFactoryEnvironment,Any}" href="#TaskGraphs.random_pctapf_def-Tuple{GraphUtils.GridFactoryEnvironment,Any}"><code>TaskGraphs.random_pctapf_def</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">instantiate_random_pctapf_def(env,config)</code></pre><p>Instantiate a random <code>PC_TAPF</code> problem based on the parameters of config.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.random_pctapf_sequence-Tuple{GraphUtils.GridFactoryEnvironment,Any}" href="#TaskGraphs.random_pctapf_sequence-Tuple{GraphUtils.GridFactoryEnvironment,Any}"><code>TaskGraphs.random_pctapf_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">instantiate_random_repeated_pctapf_problem(env,config)</code></pre><p>Instantiate a random <code>RepeatedPC_TAPF</code> problem based on the parameters of config.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.regenerate_path_specs!-Tuple{Any,Any}" href="#TaskGraphs.regenerate_path_specs!-Tuple{Any,Any}"><code>TaskGraphs.regenerate_path_specs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">regenerate_path_specs!(solver,env)</code></pre><p>Recompute all paths specs (to account for changes in the env_graphs that will be propagated to the ProblemSpec&#39;s distance function as well.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replace_in_schedule!" href="#TaskGraphs.replace_in_schedule!"><code>TaskGraphs.replace_in_schedule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">replace_in_schedule!(schedule::OperatingSchedule,path_spec::T,pred,id::ID) where {T&lt;:PathSpec,ID&lt;:AbstractID}</code></pre><p>Replace the <code>ScheduleNode</code> associated with <code>id</code> with the new node <code>pred</code>, and the accompanying <code>PathSpec</code> <code>path_spec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_config_1-Tuple{}" href="#TaskGraphs.replanning_config_1-Tuple{}"><code>TaskGraphs.replanning_config_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replanning_config_1</code></pre><p>Returns a vector of config dictionaries, which can be used to generate random problem instances for profiling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_problem-NTuple{4,Any}" href="#TaskGraphs.replanning_problem-NTuple{4,Any}"><code>TaskGraphs.replanning_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replanning_problem</code></pre><p>Constructs a replanning problem, consisting of robot initial conditions, an environment, and a sequence of project requests scheduled to arrive in the factory at regular intervals. Args:</p><ul><li><p>r0: list of integers specifying the start locations of the robots</p></li><li><p>defs: a list of tuples, where each tuple is of the form</p><p><code>([start_1=&gt;goal_1, ...], [([inputs],[outputs]),...])</code></p><p>where the <code>start=&gt;goal</code> pairs define the start and end points for each   object to be delivered, and the <code>([inputs],[outputs])</code> pairs define the   objects that go in and out of each operation.</p></li><li><p>env_graph: the environment (presumably a GridFactoryEnvironment)</p></li></ul><p>Outputs:</p><ul><li>requests: a sequence of <code>ProjectRequest</code>s</li><li>problem_spec: a <code>ProblemSpec</code></li><li>robot<em>ICs: Robot initial conditions `ROBOT</em>AT`</li><li>env_graph: the environment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_problem_3-Tuple{Any}" href="#TaskGraphs.replanning_problem_3-Tuple{Any}"><code>TaskGraphs.replanning_problem_3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">The robot should do better if it handles the single task in the second
project prior to working on the third task of the first project.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_problem_4-Tuple{Any}" href="#TaskGraphs.replanning_problem_4-Tuple{Any}"><code>TaskGraphs.replanning_problem_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Just intended to take longer so that the tests pass even if Julia hasn&#39;t
finished warming up yet.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.reset_cache!-Tuple{PlanningCache,OperatingSchedule}" href="#TaskGraphs.reset_cache!-Tuple{PlanningCache,OperatingSchedule}"><code>TaskGraphs.reset_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`reset_cache!(cache,sched)`

Resets the cache so that a solution can be repaired (otherwise calling
low_level_search!() will return immediately because the cache says it&#39;s
complete)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N,Any}} where N&lt;:ConstraintTreeNode" href="#TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N,Any}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.reset_route_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Helper to reset the solution in a constraint node between re-runs of ISPS</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.resources_reserved-Tuple{Any}" href="#TaskGraphs.resources_reserved-Tuple{Any}"><code>TaskGraphs.resources_reserved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">resources_reserved(node)</code></pre><p>Identifies the resources reserved by a particular <code>node</code> for its duration. For example, <code>resources_reserved(node::COLLECT) = AbstractID[get_location_id(node)]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.robot_ids_match-Tuple{Any,Any}" href="#TaskGraphs.robot_ids_match-Tuple{Any,Any}"><code>TaskGraphs.robot_ids_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">robot_ids_match(node,node2)</code></pre><p>Checks if robot_ids match between the nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.robot_tip_map" href="#TaskGraphs.robot_tip_map"><code>TaskGraphs.robot_tip_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">robot_tip_map(sched::OperatingSchedule)</code></pre><p>Returns a <code>Dict{RobotID,AbstractID}</code> mapping <code>RobotID</code> to the terminal node of the <code>sched</code> corresponding to the robot&#39;s last assigned task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.select_next_edges-NTuple{4,Any}" href="#TaskGraphs.select_next_edges-NTuple{4,Any}"><code>TaskGraphs.select_next_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Identifies the nodes <code>v ∈ Ai</code> and <code>v2 ∈ Ao</code> with the shortest distance <code>D[v,v2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.set_default_milp_optimizer!-Tuple{Any}" href="#TaskGraphs.set_default_milp_optimizer!-Tuple{Any}"><code>TaskGraphs.set_default_milp_optimizer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_default_milp_optimizer!(optimizer)</code></pre><p>Set the black box optimizer to be use when formulating JuMP models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair,Vararg{Any,N} where N}" href="#TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair,Vararg{Any,N} where N}"><code>TaskGraphs.set_default_optimizer_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">set_default_optimizer_attributes!(vals)</code></pre><p>Set default optimizer attributes. e.g. <code>set_default_optimizer_attributes!(Dict(&quot;PreSolve&quot;=&gt;-1))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver,Any,Any}" href="#TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver,Any,Any}"><code>TaskGraphs.solve_assignment_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solve_assignment_problem!(solver,model,prob)</code></pre><p>Solve the &quot;assignment problem&quot;–i.e., the relaxation of the full PC-TAPF problem wherein we ignore collisions–using the algorithm encoded by solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P,P}, Tuple{P,P,Any}} where P&lt;:OperatingSchedule" href="#TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P,P}, Tuple{P,P,Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.splice_schedules!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splice_schedules!(sched::P,next_sched::P) where {P&lt;:OperatingSchedule}</code></pre><p>Merge next_sched into sched</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule,ProblemSpec,Any}" href="#TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule,ProblemSpec,Any}"><code>TaskGraphs.split_active_vtxs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">split_active_vtxs!(sched::OperatingSchedule,
    problem_spec::ProblemSpec,t;</code></pre><p>Split all GO nodes that &quot;straddle&quot; the cutoff time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.split_node" href="#TaskGraphs.split_node"><code>TaskGraphs.split_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">split_node(node::N,x::LocationID)</code></pre><p>Creates two new nodes of type <code>N</code>, where the destination of the first node and the starting location of the second node are both set to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.stitch_disjoint_node_sets!-NTuple{4,Any}" href="#TaskGraphs.stitch_disjoint_node_sets!-NTuple{4,Any}"><code>TaskGraphs.stitch_disjoint_node_sets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">stitch_disjoint_node_sets!(sched,incoming,outgoing)</code></pre><p>Finds and adds the appropriate edges between two sets of nodes. It is assumed that <code>size(incoming) == size(outgoing)</code>, that each node in <code>incoming</code> has exactly one feasible successor in <code>outgoing</code>, and that each node in <code>outgoing</code> has exactly one feasible predecessor in <code>incoming</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.tighten_gaps!-Tuple{Any,AbstractPC_MAPF,SearchEnv,ConstraintTreeNode}" href="#TaskGraphs.tighten_gaps!-Tuple{Any,AbstractPC_MAPF,SearchEnv,ConstraintTreeNode}"><code>TaskGraphs.tighten_gaps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tighten_gaps!(solver, pc_mapf, env::SearchEnv, constraint_node::ConstraintTreeNode)</code></pre><p>If any path ends before it should (based on times stored in <code>get_cache(env)</code>), recomputes the path segment for the final node in that line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.trim_route_plan-Tuple{Any,Any,Any}" href="#TaskGraphs.trim_route_plan-Tuple{Any,Any,Any}"><code>TaskGraphs.trim_route_plan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trim_route_plan(search_env, route_plan, T)</code></pre><p>Construct a trimmed route_plan that stops at a certain time step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any,T,Any}} where T&lt;:TaskGraphsMILP" href="#TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any,T,Any}} where T&lt;:TaskGraphsMILP"><code>TaskGraphs.update_assignment_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_assignment_problem!(solver, assignment_problem)</code></pre><p>A helper method for updating an instance of an assignment problem. In the case     of MILP-based models, this method simply excludes all previous solutions by     adding new constraints on the assignment/adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any,SearchEnv,Int64,P}, Tuple{Any,SearchEnv,Int64,P,Any}} where P&lt;:Path" href="#TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any,SearchEnv,Int64,P}, Tuple{Any,SearchEnv,Int64,P,Any}} where P&lt;:Path"><code>TaskGraphs.update_env!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">`update_env!`

`v` is the vertex id</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_planning_cache!-Tuple{Any,Any}" href="#TaskGraphs.update_planning_cache!-Tuple{Any,Any}"><code>TaskGraphs.update_planning_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_planning_cache!(solver,env)</code></pre><p>Update cache continually. After a call to this function, the start and end times of all schedule nodes will be updated to reflect the progress of active schedule nodes (i.e., if a robot had not yet completed a GO task, the predicted final time for that task will be updated based on the robot&#39;s current state and distance to the goal). All active nodes that don&#39;t require planning will be automatically marked as complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_planning_cache!-Tuple{Any,SearchEnv,Int64,Path}" href="#TaskGraphs.update_planning_cache!-Tuple{Any,SearchEnv,Int64,Path}"><code>TaskGraphs.update_planning_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_planning_cache!(solver,env,v,path)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_project_schedule!" href="#TaskGraphs.update_project_schedule!"><code>TaskGraphs.update_project_schedule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_project_schedule!(solver,milp_model::M,sched,problem_spec,
    adj_matrix) where {M&lt;:TaskGraphsMILP}</code></pre><p>Args:</p><ul><li>milp_model &lt;: TaskGraphsMILP</li><li>sched::OperatingSchedule</li><li>problem_spec::ProblemSpec</li><li>adj<em>matrix : an adjacency</em>matrix or (in the case where   <code>milp_model::AssignmentMILP</code>), an assignment matrix</li></ul><p>Adds all required edges to the schedule graph and modifies all nodes to reflect the appropriate valid IDs (e.g., <code>Action</code> nodes are populated with the correct <code>RobotID</code>s) Returns <code>false</code> if the new edges cause cycles in the project graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_project_schedule!-Tuple{Any,OperatingSchedule,Any,Any}" href="#TaskGraphs.update_project_schedule!-Tuple{Any,OperatingSchedule,Any,Any}"><code>TaskGraphs.update_project_schedule!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">update_project_schedule!</code></pre><p>Args:</p><ul><li>solver</li><li>sched</li><li>adj<em>matrix - adjacency</em>matrix encoding the edges that need to be added to   the project schedule</li></ul><p>Adds all required edges to the project graph and modifies all nodes to reflect the appropriate valid IDs (e.g., <code>Action</code> nodes are populated with the correct <code>RobotID</code>s) Returns <code>false</code> if the new edges cause cycles in the project graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_route_plan!" href="#TaskGraphs.update_route_plan!"><code>TaskGraphs.update_route_plan!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">update_route_plan!()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.warmup" href="#TaskGraphs.warmup"><code>TaskGraphs.warmup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">warmup(loader::TaskGraphsProblemLoader,solver_config,problem_dir,dummy_path = &quot;dummy_path&quot;)</code></pre><p>Do a small dry run of <code>run_profiling(loader,solver_config,problem_dir)</code> to  ensure that all code is fully compiled before collecting results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.write_problem" href="#TaskGraphs.write_problem"><code>TaskGraphs.write_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_problem(loader::TaskGraphsProblemLoader,problem_def,prob_path,env_id=&quot;&quot;)</code></pre><p>Write a problem that can later be loaded and solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kylejbrown17/TaskGraphs.jl">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Core Types and Methods</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 21 January 2021 05:14">Thursday 21 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
