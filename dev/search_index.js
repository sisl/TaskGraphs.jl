var documenterSearchIndex = {"docs":
[{"location":"getting_started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"getting_started/#Installation","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To install TaskGraphs.jl, start up Julia and type the following code-snipped into the REPL.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"julia> ] # enter package mode by typing \"]\"\n\n(@v1.4) pkg> add https://github.com/kylejbrown17/TaskGraphs.jl.git","category":"page"},{"location":"getting_started/#Example","page":"Getting Started","title":"Example","text":"","category":"section"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"To construct and solve a predefined precedence-constrained multi agent task  assignment and pathfinding (PC-TAPF) problem.","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"using TaskGraphs\nsolver = NBSSolver() # initialize a solver\nprob = pctapf_problem_1(solver) # initialize the problem\nsolution, cost = solve!(solver,prob) # solve it\noptimal_status(solver) # check the solution status","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"If you want to build your own PC_TAPF problem from scratch:","category":"page"},{"location":"getting_started/","page":"Getting Started","title":"Getting Started","text":"# copied from TaskGraphs/scripts/pctapf_demo.jl\nusing TaskGraphs\n\n## set up the environment\nvtx_grid = initialize_dense_vtx_grid(4,4) # 4 x 4 grid world\n#  1   2   3   4\n#  5   6   7   8\n#  9  10  11  12\n# 13  14  15  16\nenv = construct_factory_env_from_vtx_grid(vtx_grid)\n\n## Define the initial conditions of the robots\nrobot_ics = [\n    ROBOT_AT(1,2), # robot 1 starts at vertex 2\n    ROBOT_AT(2,9), # robot 2 starts at vertex 9\n]\n\n## Define the manufacturing project\nspec = ProjectSpec()\n# set initial conditions of \"raw materials\"\nset_initial_condition!(spec,OBJECT_AT(1,4)) # object 1 starts at vertex 4\nset_initial_condition!(spec,OBJECT_AT(2,16))  # object 2 starts at vertex 16\n# define the operations that need to take place\nop1 = Operation(Δt=2) # operation 1 has a duration of 2 time steps \n# inputs\nset_precondition!(op1,OBJECT_AT(1,8)) # object 1 must be at vertex 8 before op1 can begin\nset_precondition!(op1,OBJECT_AT(2,12)) # object 2 must be at vertex 12 before op1 can begin\n# outputs\nset_postcondition!(op1,OBJECT_AT(3,7)) # object 3 appears at vertex 7 when op1 is completed \nadd_operation!(spec,op1)\n# add a terminal operation with no outputs\nop2 = Operation(Δt=0)\nset_precondition!(op2,OBJECT_AT(3,13))\nadd_operation!(spec,op2)\n\n## define solver\nsolver = NBSSolver()\n# finalize problem construction (the solver is passed as an argument here \n# because it determines what cost model is used for the problem)\nprob = pctapf_problem(solver,spec,env,robot_ics)\n# solve the problem\nsolution, cost = solve!(solver,prob)\n# check if the problem was solved to optimality\n@show feasible_status(solver)\n@show optimal_status(solver)","category":"page"},{"location":"library/#Core-Types","page":"Core Types and Methods","title":"Core Types","text":"","category":"section"},{"location":"library/#Planning-Predicates","page":"Core Types and Methods","title":"Planning Predicates","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"OBJECT_AT\nBOT_AT\nBOT_COLLECT\nBOT_DEPOSIT\nTEAM_ACTION","category":"page"},{"location":"library/#TaskGraphs.OBJECT_AT","page":"Core Types and Methods","title":"TaskGraphs.OBJECT_AT","text":"OBJECT_AT <: AbstractPlanningPredicate\n\nEncodes the location and shape of the object with id o\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.BOT_AT","page":"Core Types and Methods","title":"TaskGraphs.BOT_AT","text":"BOT_AT <: AbstractPlanningPredicate\n\nEncodes the location of robot with id r\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.BOT_COLLECT","page":"Core Types and Methods","title":"TaskGraphs.BOT_COLLECT","text":"BOT_COLLECT <: AbstractRobotAction\n\nEncodes the event \"robot r collects object o from x\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.BOT_DEPOSIT","page":"Core Types and Methods","title":"TaskGraphs.BOT_DEPOSIT","text":"BOT_DEPOSIT <: AbstractRobotAction\n\nEncodes the event \"robot r collects object o from x\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.TEAM_ACTION","page":"Core Types and Methods","title":"TaskGraphs.TEAM_ACTION","text":"TEAM_ACTION{R<:AbstractRobotType,A<:AbstractRobotAction{R}}\n\nFor collaborative tasks.\n\n[GO, ...] -> TEAMCOLLECT -> TEAMCARRY -> TEAM_DEPOSIT -> [GO, ...]\n\n\n\n\n\n","category":"type"},{"location":"library/#Scheduling","page":"Core Types and Methods","title":"Scheduling","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"ProjectSpec\nProblemSpec\nScheduleNode\nOperatingSchedule","category":"page"},{"location":"library/#TaskGraphs.ProjectSpec","page":"Core Types and Methods","title":"TaskGraphs.ProjectSpec","text":"ProjectSpec <: AbstractCustomNDiGraph{Union{OBJECT_AT,Operation},AbstractID}\n\nEncodes a set of operations and the prescribed initial and final locations  of the objects that form the inputs and outputs of those operations.\n\nElements:\n\nall standard fields of a concrete GraphUtils.CustomNDiGraph type\ninitialconditions::Dict{ObjectID,OBJECTAT}\nfinalconditions::Dict{ObjectID,OBJECTAT}\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ProblemSpec","page":"Core Types and Methods","title":"TaskGraphs.ProblemSpec","text":"ProblemSpec{G}\n\nEncodes the the relaxed PC-TAPF problem that ignores collision-avoidance constraints.\n\nElements:\n\nD::T - a distance matrix (or environment) that implements get_distance(D,x1,x2,args...)\ncost_function::F - the optimization objective (default is SumOfMakeSpans)\nΔt_collect::Dict{ObjectID,Int} # duration of COLLECT operations\nΔt_deposit::Dict{ObjectID,Int} # duration of DEPOSIT operations\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ScheduleNode","page":"Core Types and Methods","title":"TaskGraphs.ScheduleNode","text":"ScheduleNode{I<:AbstractID,V<:AbstractPlanningPredicate}\n\nThe node type of the OperatingSchedule graph.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.OperatingSchedule","page":"Core Types and Methods","title":"TaskGraphs.OperatingSchedule","text":"OperatingSchedule\n\nEncodes discrete events/activities that need to take place, and the precedence constraints between them. Each ScheduleNode has a corresponding vertex index and an AbstractID. An edge from node1 to node2 indicates a precedence constraint between them.\n\n\n\n\n\n","category":"type"},{"location":"library/#Path-Planning","page":"Core Types and Methods","title":"Path Planning","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"SearchEnv\nEnvState","category":"page"},{"location":"library/#TaskGraphs.SearchEnv","page":"Core Types and Methods","title":"TaskGraphs.SearchEnv","text":"SearchEnv{C,H,S} <: GraphEnv{State,Action,C}\n\nContains all of the information needed to fully define PC_TAPF and related  problems.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.EnvState","page":"Core Types and Methods","title":"TaskGraphs.EnvState","text":"EnvState\n\nReflects the state of the SearchEnv environment at a given time step.\n\n\n\n\n\n","category":"type"},{"location":"library/#Problem-Types","page":"Core Types and Methods","title":"Problem Types","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"AbstractPC_MAPF\nAbstractPC_TAPF\nPC_TAPF\nPC_TA\nPC_MAPF\nC_PC_MAPF\nC_PC_TAPF\nRepeatedAbstractPC_TAPF\nRepeatedPC_TAPF\nProjectRequest\nReplannerModel\nReplannerConfig\nDeferUntilCompletion\nReassignFreeRobots\nMergeAndBalance\nConstrainedMergeAndBalance\nReplanningProfilerCache\nFullReplanner\nReplannerWithBackup\nreplan!","category":"page"},{"location":"library/#TaskGraphs.AbstractPC_MAPF","page":"Core Types and Methods","title":"TaskGraphs.AbstractPC_MAPF","text":"AbstractPC_MAPF\n\nAn abstract type of which all Precedence-Constrained Multi-Agent Path-Finding problems are concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.AbstractPC_TAPF","page":"Core Types and Methods","title":"TaskGraphs.AbstractPC_TAPF","text":"AbstractPC_TAPF <: AbstractPC_MAPF\n\nAn abstract type of which all Precedence-Constrained Multi-Agent Task Assignment and Path-Finding problems are concrete subtypes.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.PC_TAPF","page":"Core Types and Methods","title":"TaskGraphs.PC_TAPF","text":"PC_TAPF\n\nPrecedence-Constrained Multi-Agent Task Assignment and Path-Finding problem.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.PC_TA","page":"Core Types and Methods","title":"TaskGraphs.PC_TA","text":"PC_TA\n\nPrecedence-Constrained Multi-Agent Task Assignment problem (no route planning).\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.PC_MAPF","page":"Core Types and Methods","title":"TaskGraphs.PC_MAPF","text":"PC_MAPF\n\nA precedence-constrained multi-agent path-finding problem (no task assignment).\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.C_PC_MAPF","page":"Core Types and Methods","title":"TaskGraphs.C_PC_MAPF","text":"C_PC_MAPF\n\nA collaborative precedence-constrained multi-agent path-finding problem. All agents have assigned tasks, there are precedence constraints between tasks, and some tasks must be done in teams.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.C_PC_TAPF","page":"Core Types and Methods","title":"TaskGraphs.C_PC_TAPF","text":"C_PC_TAPF\n\nDefines an instance of a Collaborative Precedence-Constrained Multi-Agent Task     Assignment and Path-Finding problem, where agents must sometimes transport     objects in teams.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.RepeatedPC_TAPF","page":"Core Types and Methods","title":"TaskGraphs.RepeatedPC_TAPF","text":"RepeatedPC_TAPF{S<:SearchEnv} <: RepeatedAbstractPC_TAPF\n\nEncodes a Repeated PCTAPF problem. Usage:     `prob = RepeatedPCTAPF(env::SearchEnv,requests::Vector{ProjectRequest})`\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ProjectRequest","page":"Core Types and Methods","title":"TaskGraphs.ProjectRequest","text":"ProjectRequest\n\nEncodes a \"request\" that arrives in the factory command center.     t_request encodes the time at which the request reaches the command center     t_arrival is the time at which the project materials will be available\n\nTODO more flexibility with t_arrival by allowing different materials to arrive at different times\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ReplannerModel","page":"Core Types and Methods","title":"TaskGraphs.ReplannerModel","text":"ReplannerModel\n\nAbstract type. Concrete subtypes currently include DeferUntilCompletion, ReassignFreeRobots, MergeAndBalance, Oracle, NullReplanner\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ReplannerConfig","page":"Core Types and Methods","title":"TaskGraphs.ReplannerConfig","text":"ReplannerConfig\n\nStores parameters for configuring an instance of ReplannerModel. Fields:\n\nreal_time::Bool - if true, adjust solver runtime limits to meet real time   operation constraints.\ntimeout_buffer::Float64 - defines the minimum amount of time that must be for   replanning the route\nrouteplanningbuffer::Float64 - defines the minimum amount of time that must   be allocated for replanning the route\ncommit_threshold::Float64 - defines where the ``freeze time'', or the time   step from which the solver may change the existing plan.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.DeferUntilCompletion","page":"Core Types and Methods","title":"TaskGraphs.DeferUntilCompletion","text":"DeferUntilCompletion <: ReplannerModel\n\nAllow work to begin on the new project only after all other work is completed.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ReassignFreeRobots","page":"Core Types and Methods","title":"TaskGraphs.ReassignFreeRobots","text":"ReassignFreeRobots   <: ReplannerModel\n\nAllow robots to begin working on the new project as soon as they have finished their current assignments.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.MergeAndBalance","page":"Core Types and Methods","title":"TaskGraphs.MergeAndBalance","text":"MergeAndBalance      <: ReplannerModel\n\nAllow replanning from scratch for all assignments and routes except for those that will take place\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ConstrainedMergeAndBalance","page":"Core Types and Methods","title":"TaskGraphs.ConstrainedMergeAndBalance","text":"ConstrainedMergeAndBalance <: ReplannerModel\n\nIdentical to MergeAndBalance, except that the replanning commit time may be pushed farther into the future to limit the total problem size at each replanning stage.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ReplanningProfilerCache","page":"Core Types and Methods","title":"TaskGraphs.ReplanningProfilerCache","text":"ReplanningProfilerCache\n\nStores information during replanning\n\nschedule - maintains (non-pruned) overall project schedule\nstage_ids - maps id of each node in schedule to stage index\nstage_results - vector of result dicts\nfeatures - vector of ::FeatureExtractors to extract after each stage\nfinal_features - vector of ::FeatureExtractors to extract after final stage\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.FullReplanner","page":"Core Types and Methods","title":"TaskGraphs.FullReplanner","text":"FullReplanner{R,S}\n\nWrapper for a ReplannerModel and a PC_TAPF solver, as well as a  ReplanningProfilerCache.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ReplannerWithBackup","page":"Core Types and Methods","title":"TaskGraphs.ReplannerWithBackup","text":"ReplannerWithBackup{A,B}\n\nConsists of a primary and a backup solver. The backup solver is supposed to be fast–it computes a \"fallback\" plan in case the primary solver fails to find a good enough solution before time out.\n\n\n\n\n\n","category":"type"},{"location":"library/#Task-Assignment-Solvers","page":"Core Types and Methods","title":"Task Assignment Solvers","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"TaskGraphsMILP\nTaskGraphsMILPSolver\nAssignmentMILP\nSparseAdjacencyMILP\nGreedyAssignment\nformulate_milp","category":"page"},{"location":"library/#TaskGraphs.TaskGraphsMILP","page":"Core Types and Methods","title":"TaskGraphs.TaskGraphsMILP","text":"TaskGraphsMILP\n\nConcrete subtypes of TaskGraphsMILP define different ways to formulate the sequential assignment portion of a PC-TAPF problem.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.TaskGraphsMILPSolver","page":"Core Types and Methods","title":"TaskGraphs.TaskGraphsMILPSolver","text":"TaskGraphsMILPSolver\n\nWrapper for MILP solver for assignment problem.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.AssignmentMILP","page":"Core Types and Methods","title":"TaskGraphs.AssignmentMILP","text":"AssignmentMILP <: TaskGraphsMILP\n\nUsed to formulate a MILP where the decision variable is a matrix X, where X[i,j] = 1 means that robot i is assigned to delivery task j. The dimensionality of X is (N+M) × M, where N is the number of robots and M is the number of delivery tasks. the last M rows of X correspond to \"dummy robots\", i.e. the N+jth row corresponds to \"the robot that already completed task j\". The use of these dummy robot variables allows the sequential assignment problem to be posed as a one-off assignment problem with inter-task constraints.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.SparseAdjacencyMILP","page":"Core Types and Methods","title":"TaskGraphs.SparseAdjacencyMILP","text":"SparseAdjacencyMILP <: TaskGraphsMILP\n\nFormulates a MILP where the decision variable is a sparse adjacency matrix X     for the operating schedule graph. If X[i,j] = 1, there is an edge from     node i to node j. Experiments have shown that the sparse matrix approach leads to much faster solve times than the dense matrix approach.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.GreedyAssignment","page":"Core Types and Methods","title":"TaskGraphs.GreedyAssignment","text":"GreedyAssignment{C,M} <: TaskGraphsMILP\n\nGreedyAssignment maintains three sets: The \"satisfied set\" C, the \"required incoming\" set Ai, and the \"available outgoing\" set Ao.\n\nAt each step, the algorithm identifies the nodes v1 ∈ Ai and v2 ∈ Ao with shortest \"distance\" (in the context of OperatingSchedules, this distance refers to the duration of v1 if an edge v1 → v2 is added) and adds an edge between them. The distance corresponding to an ineligible edge is set to Inf.\n\nAfter adding the edge, the algorithm sweeps through a topological ordering of the vertices and updates C, Ai, and Ao. In order for v to be placed in C, v must have enough incoming edges and all of v's predecessors must already be in C. In order to be added to Ai, v must have less than the required number of incoming edges and all of v's predecessors must already be in C. In order for v to be added to Ao, v must have less than the allowable number of outgoing edges, and must be in C.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.formulate_milp","page":"Core Types and Methods","title":"TaskGraphs.formulate_milp","text":"formulate_milp(milp_model::AssignmentMILP,sched,problem_spec;kwargs...)\n\nExpress the TaskGraphs assignment problem as an AssignmentMILP using the JuMP optimization framework.\n\nInputs:     milpmodel::T <: TaskGraphsMILP : a milp model that determines how the         sequential task assignment problem is modeled. Current options are         AssignmentMILP, SparseAdjacencyMILP and GreedyAssignment.     sched::OperatingSchedule : a partial operating schedule, where         some or all assignment edges may be missing.     problemspec::ProblemSpec : encodes the distance matrix and other         information about the problem.\n\nKeyword Args:     optimizer - a JuMP optimizer (e.g., Gurobi.optimizer)     cost_model=MakeSpan - optimization objective, currently either MakeSpan         or SumOfMakeSpans. Defaults to the costmodel associated with         `problemspecOutputs:model::AssignmentMILP` - an instantiated optimization problem\n\n\n\n\n\n","category":"function"},{"location":"library/#Route-Planners","page":"Core Types and Methods","title":"Route Planners","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"AStarSC\nISPS\nPIBTPlanner\nCBSSolver","category":"page"},{"location":"library/#TaskGraphs.AStarSC","page":"Core Types and Methods","title":"TaskGraphs.AStarSC","text":"AStarSC\n\nLow-level path planner that employs Slack-and-Collision-Aware A*. Fields:\n\nlogger\nreplan : if true, planner will replan with an empty conflict table following   timeout.\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.ISPS","page":"Core Types and Methods","title":"TaskGraphs.ISPS","text":"ISPS\n\nPath planner that employs Incremental Slack-Prioritized Search.\n\n\n\n\n\n","category":"type"},{"location":"library/#PC_TAPF-Solvers","page":"Core Types and Methods","title":"PC_TAPF Solvers","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"NBSSolver\n<!-- SolverLogger -->\nsolve!\nformulate_assignment_problem\nupdate_assignment_problem!\nsolve_assignment_problem!\nconstruct_cost_model\nplan_route!","category":"page"},{"location":"library/#TaskGraphs.NBSSolver","page":"Core Types and Methods","title":"TaskGraphs.NBSSolver","text":"NBSSolver{A,P}\n\nA hierarchical PC-TAPF solver with an assignment level and a path-planning level. The solver works by alternating between assignment and path-planning until the optimality gap between the lower bound (from task assignment) and the lower bound (from path planning) disappears. The input to the assignment problem is the full PC-TAPF problem specification. The output of the assignment problem is a valid OperatingSchedule–that is, an operating schedule wherein all assignments have been made in a legal way. The input to the route planner is the PC-TAPF problem spec along with the OperatingSchedule that comes from the assignment solution.\n\n\n\n\n\n","category":"type"},{"location":"library/#Profiling-Tools","page":"Core Types and Methods","title":"Profiling Tools","text":"","category":"section"},{"location":"library/","page":"Core Types and Methods","title":"Core Types and Methods","text":"TaskGraphsProblemLoader\nwrite_problem\nload_problem\nrun_profiling\nwarmup","category":"page"},{"location":"library/#TaskGraphs.TaskGraphsProblemLoader","page":"Core Types and Methods","title":"TaskGraphs.TaskGraphsProblemLoader","text":"TaskGraphsProblemLoader{T}\n\nHelper cache for loading problems of type T\n\n\n\n\n\n","category":"type"},{"location":"library/#TaskGraphs.write_problem","page":"Core Types and Methods","title":"TaskGraphs.write_problem","text":"write_problem(loader::TaskGraphsProblemLoader,problem_def,prob_path,env_id=\"\")\n\nWrite a problem that can later be loaded and solved.\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.load_problem","page":"Core Types and Methods","title":"CRCBS.load_problem","text":"CRCBS.load_problem(loader::TaskGraphsProblemLoader,solver_config,prob_path)\n\nCurrently only impemented for PCTAPF and PCTA\n\n\n\n\n\n","category":"function"},{"location":"library/#CRCBS.run_profiling","page":"Core Types and Methods","title":"CRCBS.run_profiling","text":"CRCBS.run_profiling(loader::TaskGraphsProblemLoader,solver_config,problem_dir)\n\nRun profiling with a TaskGraphsProblemLoader.\n\n\n\n\n\n","category":"function"},{"location":"library/#TaskGraphs.warmup","page":"Core Types and Methods","title":"TaskGraphs.warmup","text":"warmup(loader::TaskGraphsProblemLoader,solver_config,problem_dir,dummy_path = \"dummy_path\")\n\nDo a small dry run of run_profiling(loader,solver_config,problem_dir) to  ensure that all code is fully compiled before collecting results.\n\n\n\n\n\n","category":"function"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"reference/#Docs","page":"API Reference","title":"Docs","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [TaskGraphs]","category":"page"},{"location":"reference/#TaskGraphs.GADGET_EDGE_MULTIPLIER","page":"API Reference","title":"TaskGraphs.GADGET_EDGE_MULTIPLIER","text":"The number of edges in each \"gadget\" per original edge\n\n\n\n\n\n","category":"constant"},{"location":"reference/#TaskGraphs.AbstractPCTAPFSolver","page":"API Reference","title":"TaskGraphs.AbstractPCTAPFSolver","text":"AbstractPCTAPFSolver\n\nAbstract type of which all PC-TAPF solvers must be concrete subtypes. All concrete solvers must implement the following interface for solving PC-TAPF problems:\n\nsolution, cost = solve!(solver,problem_def)\ncheck_runtime(solver) should trigger an interrupt + early return if the   allowable runtime has been exceeded\n\nAlso, we need a good Logger type for keeping track of thing like runtime, iterations, optimality gap (including upper and lower bound), etc.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.BOT_CARRY","page":"API Reference","title":"TaskGraphs.BOT_CARRY","text":"BOT_CARRY <: AbstractRobotAction\n\nEncodes the event \"robot r carries object o from x1 to x2\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.BOT_GO","page":"API Reference","title":"TaskGraphs.BOT_GO","text":"BOT_GO <: AbstractRobotAction\n\nEncodes the event \"robot r goes from x1 to x2\"\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.CLEAN_UP","page":"API Reference","title":"TaskGraphs.CLEAN_UP","text":"CLEAN_UP <: AbstractRobotAction\n\nEncodes the event \"robot r cleans up locations vtxs`\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.CleanUpBot","page":"API Reference","title":"TaskGraphs.CleanUpBot","text":"CleanUpBot <: AbstractRobotType\n\nA robot type for picking up dropped objects, cleaning up spills, and taking  care of dead robots\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.DeadRobot","page":"API Reference","title":"TaskGraphs.DeadRobot","text":"DeadRobot\n\nRobot id is frozen.\n\nEffect:\n\nFreeze robot\nAdd \"no-go\" constraint to CBS/PIBT (how to do consistently? Perhaps place in   SearchEnv and add directly to PCCBSEnv) OR temporarily remove vertex from   graph\nSet robot state to NULL state? How to avoid having CBS complain about   conflicts? Maybe set State to NULL State and place DeadRobotObject at the   collection site?\nDispatch CleanUpBot to collect frozen robot\nWhen CleanUpBot returns to \"garage\", regenerate frozen Robot's ROBOT_AT node   and valid state.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.DelayedRobot","page":"API Reference","title":"TaskGraphs.DelayedRobot","text":"DelayedRobot\n\nRobot id is delayed by dt timesteps.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.DroppedObject","page":"API Reference","title":"TaskGraphs.DroppedObject","text":"DroppedObject\n\nObject id dropped.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.GadgetGraph","page":"API Reference","title":"TaskGraphs.GadgetGraph","text":"GadgetGraph\n\nRepresents a time-extended graph useful for MILP formulations\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.Intruder","page":"API Reference","title":"TaskGraphs.Intruder","text":"Intruder\n\nAn intruder that begins at location start_vtx and follows policy policy\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.OilSpill","page":"API Reference","title":"TaskGraphs.OilSpill","text":"OilSpill\n\nAn obstruction that affects vertices vtxs and edges edges.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.Operation","page":"API Reference","title":"TaskGraphs.Operation","text":"Operation <: AbstractPlanningPredicate\n\nA manufacturing operation.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.PathSpec","page":"API Reference","title":"TaskGraphs.PathSpec","text":"PathSpec\n\nEncodes information about the path that must be planned for a particular schedule node.\n\nFields:\n\nnode_type::Symbol = :EMPTY\nstart_vtx::Int = -1\nfinal_vtx::Int = -1\nmin_duration::Int = 0\nagent_id::Int = -1\nobject_id::Int = -1\nplan_path::Bool = true - flag indicating whether a path must be planned.   For example, Operation nodes do not require any path planning.\ntight::Bool = false - if true, the path may not terminate prior to the   beginning of successors. If tight == true, local slack == 0. For example,   GO must not end before COLLECT can begin, because this would produce   empty time between planning phases.\nstatic::Bool = false - if true, the robot must remain in place for this   planning phase (e.g., COLLECT, DEPOSIT).\nfree::Bool = false - if true, and if the node is a terminal node, the   planning must go on until all non-free nodes are completed.\nfixed::Bool = false - if true, do not plan path because it is already fixed.   Instead, retrieve the portion of the path directly from the pre-existing   solution.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.PrioritizedAStarSC","page":"API Reference","title":"TaskGraphs.PrioritizedAStarSC","text":"PrioritizedAStarSC\n\nLow-level proritized path planner that employs Slack-and-Collision-Aware A*.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.SimpleRepeatedProblemDef","page":"API Reference","title":"TaskGraphs.SimpleRepeatedProblemDef","text":"SimpleRepeatedProblemDef\n\nIntermediate representation of a RepeatedPC_TAPF (useful for I/O)\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.SimpleReplanningRequest","page":"API Reference","title":"TaskGraphs.SimpleReplanningRequest","text":"SimpleReplanningRequest\n\nIntermediate representation of a ProjectRequest (useful for I/O)\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.StochasticProblem","page":"API Reference","title":"TaskGraphs.StochasticProblem","text":"StochasticProblem{P<:AbstractPC_TAPF}\n\nDefines a stochastic version of PC_TAPF, wherein different disturbances can cause unexpected problems in the factory.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.TeamAssignmentMILP","page":"API Reference","title":"TaskGraphs.TeamAssignmentMILP","text":"TeamAssignmentMILP\n\n***Not yet implemented.***\n\nEextend the assignment matrix formulation of AssignmentMILP to the \"team-forming\" case where robots must collaboratively transport some objects.\n\n\n\n\n\n","category":"type"},{"location":"reference/#TaskGraphs.UNDERTAKE","page":"API Reference","title":"TaskGraphs.UNDERTAKE","text":"UNDERTAKE <: AbstractRobotAction{CleanUpBot}\n\nEncodes the task of collecting, carrying, and depositing a dead robot\n\n\n\n\n\n","category":"type"},{"location":"reference/#CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any,C_PC_MAPF,E,N,T,Int64}} where T where N<:ConstraintTreeNode where E<:SearchEnv","page":"API Reference","title":"CRCBS.build_env","text":"For COLLABORATIVE transport problems\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.load_problem-Tuple{TaskGraphsProblemLoader,Any,Any}","page":"API Reference","title":"CRCBS.load_problem","text":"CRCBS.load_problem(loader::TaskGraphsProblemLoader,solver_config,prob_path)\n\nCurrently only impemented for PCTAPF and PCTA\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.pibt_update_solution!-Tuple{Any,SearchEnv,Any}","page":"API Reference","title":"CRCBS.pibt_update_solution!","text":"CRCBS.pibt_update_solution!(solver,pc_mapf::PC_MAPF,solution::SearchEnv,cache)\n\nOverridden to update the SearchEnv\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader,Any,Any}","page":"API Reference","title":"CRCBS.run_profiling","text":"CRCBS.run_profiling(loader::TaskGraphsProblemLoader,solver_config,problem_dir)\n\nRun profiling with a TaskGraphsProblemLoader.\n\n\n\n\n\n","category":"method"},{"location":"reference/#CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver,E}} where E<:AbstractPC_TAPF","page":"API Reference","title":"CRCBS.solve!","text":"solve!(solver, base_env::SearchEnv;kwargs...) where {A,P}\n\nUse the planner defined by solver to solve the PC-TAPF problem encoded by base_env. For solvers of type NBSSolver, the algorithm involves repeatedly solving an assignment problem followed by a route-planning problem. Within the generic solve! method it is possible to initialize an assignment problem (the type is not constrained) and then modify it via update_assignment_problem! prior to each new call to solve_assignment_problem!. This is the approach taken for various MILP-based assignment solvers. It is also possible to reconstruct the assignment problem from scratch within each call to solve_assignment_problem!.\n\nArguments:\n\nsolver <: AbstractPCTAPFSolver\nbase_env::SearchEnv : a PC-TAPF problem\n\nOutputs:\n\nbest_env : a SearchEnv data structure that encodes a solution to the problem\ncost : the cost of the solution encoded by best_env\n\n\n\n\n\n","category":"method"},{"location":"reference/#JuMP.optimize!-Tuple{GreedyAssignment}","page":"API Reference","title":"JuMP.optimize!","text":"GreedyAssignment maintains three sets: The \"satisfied set\" C, the \"required incoming\" set Ai, and the \"available outgoing\" set Ao.\n\nAt each step, the algorithm identifies the nodes v1 ∈ Ai and v2 ∈ Ao with shortest \"distance\" (in the context of OperatingSchedules, this distance refers to the duration of v1 if an edge v1 → v2 is added) and adds an edge between them. The distance corresponding to an ineligible edge is set to Inf.\n\nAfter adding the edge, the algorithm sweeps through a topological ordering of the vertices and updates C, Ai, and Ao. In order for v to be placed in C, v must have enough incoming edges and all of v's predecessors must already be in C. In order to be added to Ai, v must have less than the required number of incoming edges and all of v's predecessors must already be in C. In order for v to be added to Ao, v must have less than the allowable number of outgoing edges, and must be in C.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}","page":"API Reference","title":"TaskGraphs.add_job_shop_constraints!","text":"add_job_shop_constraints!(milp_model::AssignmentMILP,sched::OperatingSchedule,spec::ProblemSpec) #,model::JuMP.Model)\n\nAfter an AssignmentMILP has been optimized, add in any edges that result from an active ``job shop'' constraint (where two robots require the same resource).\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph,Any}","page":"API Reference","title":"TaskGraphs.add_movement_vtx!","text":"add_movement_vtx!\n\nFlags a vertex of the gadget graph as corresponding to a non-\"wait\" edge\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule,Any}","page":"API Reference","title":"TaskGraphs.adj_mat_from_assignment_mat","text":"adj_mat_from_assignment_mat(sched,assignment_matrix)\n\nCompute an adjacency matrix from an assignment matrix\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.align_with_predecessor-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.align_with_predecessor","text":"align_with_predecessor(node,succ)\n\nModifies a node to match the information encoded by its predecessor. This is how e.g., robot ids are propagated through an existing operating schedule after assignments (or re-assignments) have been made.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.align_with_successor-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.align_with_successor","text":"align_with_successor(node,succ)\n\nModifies a node to match the information encoded by its successor. This is how e.g., robot ids are propagated through an existing operating schedule after assignments (or re-assignments) have been made.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.backtrack_node-Tuple{OperatingSchedule,Int64}","page":"API Reference","title":"TaskGraphs.backtrack_node","text":"`backtrack_node(sched::OperatingSchedule,v::Int)`\n\nFind the closest ancestor of v with overlapping RobotIDs.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.break_assignments!-Tuple{OperatingSchedule,ProblemSpec}","page":"API Reference","title":"TaskGraphs.break_assignments!","text":"break_assignments!(sched::OperatingSchedule,problem_spec::ProblemSpec)\n\nBreak all assignments that are eligible for replanning\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.check_object_id-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.check_object_id","text":"Check if a node is associated with objectid\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.choose_random_object_sizes-Tuple{Any,Dict{Tuple{Int64,Int64},Float64}}","page":"API Reference","title":"TaskGraphs.choose_random_object_sizes","text":"Tool for randomly selecting how many robots (and in what configuration)\n    should deliver each task.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.clear_default_optimizer_attributes!-Tuple{}","page":"API Reference","title":"TaskGraphs.clear_default_optimizer_attributes!","text":"clear_default_optimizer_attributes!()\n\nClear the default optimizer attributes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.compute_lower_bound","page":"API Reference","title":"TaskGraphs.compute_lower_bound","text":"compute_lower_bound(env,[starts,assigned,dist_mtx,pairs])\n\nComputes a lower bound on makespan for sched::OperatingSchedule by assuming     that any robot can be simultaneously assigned to multiple tasks.\n\nArgs:\n\nenv      SearchEnv\nstarts   the set of vertices whose outgoing edges are available\nassigned the set of vertices whose incoming edges are already assigned\ndist_mtx encodes the cost of each edge v -> vp as dist_mtx[v,vp]\npairs    specifies eligible edges\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,N}, Tuple{ISPS,AbstractPC_MAPF,N,SearchEnv}} where N<:ConstraintTreeNode","page":"API Reference","title":"TaskGraphs.compute_route_plan!","text":"compute_route_plan!\n\nComputes all paths specified by the project schedule and updates the solution in the ConstraintTreeNode::node accordingly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.construct_cost_model","page":"API Reference","title":"TaskGraphs.construct_cost_model","text":"construct_cost_model(solver::AStarSC, args...;kwargs...)\n\nDefines the cost model used by Slack- and Collision-aware A*. This particular setting of cost model is crucial for good performance of A_star, because it encourages depth first search. If we were to replace terms 3-5 with SumOfTravelTime(), we would get worst-case exponentially slow breadth-first search!\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_heuristic_model","page":"API Reference","title":"TaskGraphs.construct_heuristic_model","text":"construct_heuristic_model(solver,env_graph;kwargs...)\n\nConstruct the heuristic model to be used by solver.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_operation","page":"API Reference","title":"TaskGraphs.construct_operation","text":"construct_operation(spec::ProjectSpec, station_id, input_ids, output_ids, Δt, id=get_unique_operation_id())\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_partial_project_schedule","page":"API Reference","title":"TaskGraphs.construct_partial_project_schedule","text":"construct_partial_project_schedule\n\nConstructs a partial project graph\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_random_project_spec-Tuple{Int64,Array{OBJECT_AT,1},Array{OBJECT_AT,1}}","page":"API Reference","title":"TaskGraphs.construct_random_project_spec","text":"construct_random_project_spec(M::Int;max_children=1)\n\nInputs:\n    `M` - number of objects involved in the operation\n    `max_parents` - determines the max number of inputs to any operation\n    `depth_bias` ∈ [0,1] - hyperparameter for tuning depth.\n        If `depth_bias` == 1.0, the project_spec graph will always be depth\n        balanced (all paths through the tree will be of the same length).\n        For `depth_bias` == 0.0, the graph will be as \"strung out\" as\n        possible.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.construct_random_task_graphs_problem","page":"API Reference","title":"TaskGraphs.construct_random_task_graphs_problem","text":"`construct_randomd_task_graphs_problem`\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_search_env","page":"API Reference","title":"TaskGraphs.construct_search_env","text":"function construct_search_env(solver, env::SearchEnv, ... )\n\nConstruct a new SearchEnv, with costmodel and heuristicmodel defined by the  solver type.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_search_env-2","page":"API Reference","title":"TaskGraphs.construct_search_env","text":"construct_search_env(solver,schedule,env,...)\n\nConstructs a new search env by combining the new schedule with the pre- existing get_route_plan(env). This involves constructing a new cost function that reflects the new schedule structure. TODO: Carry over information about get_cache(search_env)\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec,Array{Int64,1},Array{Int64,1},Array{Int64,1},Any}","page":"API Reference","title":"TaskGraphs.construct_task_graphs_problem","text":"`construct_task_graphs_problem`\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}","page":"API Reference","title":"TaskGraphs.convert_env_graph_to_undirected","text":"It is necessary to convert the env graph to an undirected graph because the\ngadget is based on undirected edges. Self-edges also need to be removed, as\nthese are already accounted for in the gadget.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.default_milp_optimizer-Tuple{}","page":"API Reference","title":"TaskGraphs.default_milp_optimizer","text":"default_milp_optimizer()\n\nReturns the black box optimizer to be use when formulating JuMP models.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.default_optimizer_attributes-Tuple{}","page":"API Reference","title":"TaskGraphs.default_optimizer_attributes","text":"default_optimizer_attributes()\n\nReturn a dictionary of default optimizer attributes.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.evaluate_path_gap-Tuple{SearchEnv,Any,Any}","page":"API Reference","title":"TaskGraphs.evaluate_path_gap","text":"evaluate_path_gap(search_env::SearchEnv,path,v)\n\nReturns the gap between a path's length and it's expected length (based on times stored in get_cache(env).t0)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.exclude_solutions!-Tuple{JuMP.Model,Array{Int64,2}}","page":"API Reference","title":"TaskGraphs.exclude_solutions!","text":"exclude_solutions!(model::JuMP.Model,forbidden_solutions::Vector{Matrix{Int}})\n\nAdds constraints to model such that the solution may not match any solution contained in forbiddensolutions. Assumes that the model contains a variable container called X whose entries are binary and whose dimensions are identical to the dimensions of each solution in forbiddensolutions.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule,ProblemSpec,Any}","page":"API Reference","title":"TaskGraphs.fix_precutoff_nodes!","text":"fix_precutoff_nodes!(sched::OperatingSchedule,\n    problem_spec::ProblemSpec,t)\n\nIdentify all nodes that end before the cutoff time, and change their path spec     so that the route planner will not actually plan a path for them.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.formulate_assignment_problem-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.formulate_assignment_problem","text":"formulate_assignment_problem(solver,prob;\n\nReturns an assignment problem instance that can be updated (as opposed to being reconstructed from scratch) on each call to update_assignment_problem! prior to being resolved.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.formulate_big_milp","page":"API Reference","title":"TaskGraphs.formulate_big_milp","text":"formulate_big_milp\n\nFormulate a PCTAPF problem as a giant network flow MILP.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.formulate_milp-Tuple{AssignmentMILP,OperatingSchedule,ProblemSpec}","page":"API Reference","title":"TaskGraphs.formulate_milp","text":"formulate_milp(milp_model::AssignmentMILP,sched,problem_spec;kwargs...)\n\nExpress the TaskGraphs assignment problem as an AssignmentMILP using the JuMP optimization framework.\n\nInputs:     milpmodel::T <: TaskGraphsMILP : a milp model that determines how the         sequential task assignment problem is modeled. Current options are         AssignmentMILP, SparseAdjacencyMILP and GreedyAssignment.     sched::OperatingSchedule : a partial operating schedule, where         some or all assignment edges may be missing.     problemspec::ProblemSpec : encodes the distance matrix and other         information about the problem.\n\nKeyword Args:     optimizer - a JuMP optimizer (e.g., Gurobi.optimizer)     cost_model=MakeSpan - optimization objective, currently either MakeSpan         or SumOfMakeSpans. Defaults to the costmodel associated with         `problemspecOutputs:model::AssignmentMILP` - an instantiated optimization problem\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.generate_path_spec-Tuple{ProblemSpec,Any}","page":"API Reference","title":"TaskGraphs.generate_path_spec","text":"generate_path_spec(spec,node)\n\nGenerates a PathSpec struct that encodes information about the path to be planned for node.\n\nArguments:\n\nspec::ProblemSpec\nnode::T <: AbstractPlanningPredicate\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule,Any}","page":"API Reference","title":"TaskGraphs.get_active_and_fixed_vtxs","text":"get_active_and_fixed_vtxs(sched::OperatingSchedule,t)\n\n\"active\" vertices \"straddle\" the query time t \"fixed\" vertices finish before the query time t\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_assignment_dict-Tuple{Any,Any,Any}","page":"API Reference","title":"TaskGraphs.get_assignment_dict","text":"get_assignment_dict(assignment_matrix,N,M)\n\nReturns dictionary that maps each robot id to a sequence of tasks.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule,GraphUtils.ObjectID}","page":"API Reference","title":"TaskGraphs.get_delivery_task_vtxs","text":"get_delivery_task_vtxs(sched::OperatingSchedule,o::ObjectID)\n\nReturn all vertices that correspond to the delivery task (COLLECT → CARRY → DEPOSIT) of object o.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_duration_vector-Tuple{ProjectSpec}","page":"API Reference","title":"TaskGraphs.get_duration_vector","text":"get_duration_vector(spec::ProjectSpec)\n\nReturn a vector Δt such that Δt[i] is the amount of time that must elapse  before object i can be picked up after its parent operation is performed.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_env_snapshot-Tuple{SearchEnv,Any}","page":"API Reference","title":"TaskGraphs.get_env_snapshot","text":"get_env_snapshot(route_plan::S,t)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv,Any}","page":"API Reference","title":"TaskGraphs.get_next_node_matching_agent_id","text":"get_next_node_matching_agent_id(schedule,cache,agent_id)\n\nReturn the node_id of the active node assigned to an agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv,Any}","page":"API Reference","title":"TaskGraphs.get_next_vtx_matching_agent_id","text":"get_next_vtx_matching_agent_id(schedule,cache,agent_id)\n\nReturn the node_id of the active node assigned to an agent.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}","page":"API Reference","title":"TaskGraphs.get_node_start_and_end_times","text":"get_start_and_end_maps(sched,cache,default=0)\n\nReturn dictionaries mapping each node id in schedule to its start and end time\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_objective_expr-Tuple{AssignmentMILP,MultiDeadlineCost{SumCost}}","page":"API Reference","title":"TaskGraphs.get_objective_expr","text":"get_objective_expr\n\nHelper for setting the objective function for a milp model\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_random_problem_instantiation-Tuple{Int64,Int64,Any,Any,Any}","page":"API Reference","title":"TaskGraphs.get_random_problem_instantiation","text":"`get_random_problem_instantiation`\n\nArgs:\n- `N`: number of robots\n- `M`: number of delivery tasks\n- `robot_zones`: list of possible start locations for robots\n- `pickup_zones`: list of possible start locations for objects\n- `dropoff_zones`: list of possible destinations for objects\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_sF-Tuple{AssignmentMILP}","page":"API Reference","title":"TaskGraphs.get_sF","text":"get_sF(milp_model::AssignmentMILP)\n\nReturn an a vector of final object locations.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph,Any,Any}","page":"API Reference","title":"TaskGraphs.get_source_map","text":"Return a source map such that source_map[v][t] points to the corresponding\nvertex in the gadget graph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule,A}, Tuple{OperatingSchedule,A,Any}} where A<:Union{GraphUtils.ActionID, GraphUtils.BotID}","page":"API Reference","title":"TaskGraphs.get_valid_robot_ids","text":"get_valid_robot_ids(sched::OperatingSchedule,node_id::AbstractID)\n\nReturns vector of all robot ids associated with the schedule node referenced by node_id.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.handle_disturbance!","page":"API Reference","title":"TaskGraphs.handle_disturbance!","text":"handle_disturbance!(solver,prob,env,d::DroppedObject,t,env_state=get_env_state(env,t))\n\nReturns a new SearchEnv with a modified OperatingSchedule. The new schedule replaces the previous delivery task (OBJECT_AT(o,old_x) → COLLECT → CARRY → DEPOSIT) with a new CleanUpBot delivery task (OBJECT_AT(o,new_x) → CUB_COLLECT → CUB_CARRY → CUB_DEPOSIT). It is assumed that the time t corresponds to a moment when the object referred to by d.id is being CARRIED.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.isolate_delivery_task_vtxs","page":"API Reference","title":"TaskGraphs.isolate_delivery_task_vtxs","text":"isolate_delivery_task_vtxs(sched,o,vtxs=get_delivery_task_vtxs(sched,o))\n\nReturns:\n\nincoming: a set of all incoming Action ScheduleNodes\noutgoing: a set of all outgoing Action ScheduleNodes\nop: the target Operation\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A,Type{B}}} where B where A","page":"API Reference","title":"TaskGraphs.matches_node_type","text":"matches_node_type(::A,::Type{B}) where {A<:AbstractPlanningPredicate,B}\n\nReturns true if {A <: B}\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_1-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_1","text":"pctapf_problem_1\n\nOptimal MakeSpan = 5 Optimal SumOfMakeSpans = 5\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_10-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_10","text":"pctapf_problem_10(;cost_function=MakeSpan(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0,0,0],Δt_deposit=[0,0,0,0,0,0])\n\nMotivation for backtracking in ISPS The makespan optimal solution is T = 8. However, the optimistic schedule will always prioritize task route planning for tasks 1,2, and 3 before 4. This leads to a double delay that will not be caught without backtracking in ISPS. Hence, the solver will return a solution with T = 9.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_11-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_11","text":"pctapf_problem_11\n\nRequires collaborative transport: Robots 1 and 2 transport object 1 while robot 3 transports object 2. Robot 3 will need to move over to let the other robots pass.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_12-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_12","text":"pctapf_problem_12(;\n\nRobot 1 will plan a path first, but then that path will need to be extended by one time step because robot 2 will get delayed by robot 3, which is on the critical path.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_13-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_13","text":"pctapf_problem_13\n\nSame as pctapf_problem_12, except that there is a 4th robot who must collect  object 1 with robot 1.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_2-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_2","text":"pctapf_problem_2(;cost_function=SumOfMakeSpans(),verbose=false)\n\nIn this problem robot 1 will first do [1-9-17], then [17-21-35] robot 2 will do [4-12-32]. The key thing is that robot 1 will need to wait until robot 2 is finished before robot 1 can do its second task.\n\nOptimal paths: Optimal MakeSpan = 8 Optimal SumOfMakeSpans = 8\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_3-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_3","text":"pctapf_problem_3(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0],Δt_deposit=[0,0,0,0])\n\nIn this problem robot 2 will need to yield to let robot 1 through. First operation:     robot 1 does [2-2-30] Second operation:     robot 1 does [30-30-32]     robot 2 does [5-7-8] Third operation:     robot 2 does [8-12-16]\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_4-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_4","text":"pctapf_problem_4(;cost_function=SumOfMakeSpans(),verbose=false)\n\nIn this problem the cost of the task assignment problem is lower than the true cost (which requires that one of the robots is delayed by a single time step) First operation:     robot 1 does [2-2-8]     robot 2 does [4-4-6]\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_5-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_5","text":"pctapf_problem_5(;cost_function=SumOfMakeSpans(),verbose=false)\n\nIn this problem the robots try to pass through each other in such a way that an edge conflict is generated.\n\nFirst operation:     robot 1 does [3-11]     robot 2 does [15-7]\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_6-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_6","text":"pctapf_problem_6(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=1,Δt_collect=[0,0,0],Δt_deposit=[0,0,0])\n\nIdentical to pctapf_problem_2, but process time is non-zero. In this problem robot 1 will first do [1-5-9], then [9-13-17] robot 2 will do [4-8-32]. The key thing is that robot 1 will need to wait until robot 2 is finished before robot 1 can do its second task\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_7-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_7","text":"pctapf_problem_7(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,4,0],Δt_deposit=[0,0,0])\n\nRobot 2 will have to sit and wait at the pickup station, meaning that robot 1  will have to go around if robot 2 is on the critical path\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_8-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_8","text":"pctapf_problem_8(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0],Δt_deposit=[0,0,0,0])\n\nTwo-headed project. Robot 1 does the first half of the first head, and robot 2 handles the first half of the second head, and then they swap. Optimal MakeSpan = 8 Optimal SumOfMakeSpans = 16\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.pctapf_problem_9-Tuple{}","page":"API Reference","title":"TaskGraphs.pctapf_problem_9","text":"pctapf_problem_9(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0],Δt_deposit=[0,0])\n\nProject with station-sharing. Station 5 needs to accessed by both robots for  picking up their objects.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS,AbstractPC_MAPF,SearchEnv,N}} where N<:ConstraintTreeNode","page":"API Reference","title":"TaskGraphs.plan_next_path!","text":"`plan_next_path`\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC,AbstractPC_MAPF,SearchEnv,N,T,Int64}} where T where N<:ConstraintTreeNode","page":"API Reference","title":"TaskGraphs.plan_path!","text":"plan_path!\n\nComputes next path specified by the project schedule and updates the\nsolution in the ConstraintTreeNode::node accordingly.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.plan_route!-Tuple{Any,Any,Any}","page":"API Reference","title":"TaskGraphs.plan_route!","text":"plan_route!\n\nCompute a route plan that corresponds to the OperatingSchedule. Arguments:\n\nsolver\nschedule\nsearch_env\n\nOutputs:\n\nA SearchEnv the contains a valid solution\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.post_process_replanning_results!-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.post_process_replanning_results!","text":"add start_time, completion_time, and makespan for each stage\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.preprocess_project_schedule-Tuple{Any}","page":"API Reference","title":"TaskGraphs.preprocess_project_schedule","text":"preprocess_project_schedule(sched)\n\nReturns information about the eligible and required successors and predecessors of nodes in sched\n\nArguments:\n\nsched::OperatingSchedule\n\nOutputs:\n\nmissing_successors\nmissing_predecessors\nneligiblesuccessors\nneligiblepredecessors\nnrequiredsuccessors\nnrequiredpredecessors\nupstream_vertices\nnonupstreamvertices\n\nTODO: OBJECTAT nodes should always have the properties that `indegree(G,v) == nrequiredpredecessors(v) == neligiblepredecessors(v)outdegree(G,v) == nrequiredsuccessors(v) == neligible_successors(v)` Not sure if this is currently the case. UPDATE: I believe this has already been     addressed by making each object come from an initial operation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P,Any}, Tuple{P,Any,Any}} where P<:OperatingSchedule","page":"API Reference","title":"TaskGraphs.process_schedule","text":"process_schedule(schedule::P) where {P<:OperatingSchedule}\n\nCompute the optimistic start and end times, along with the slack associated with each vertex in the schedule. Slack for each vertex is represented as a vector in order to handle multi-headed projects.\n\nArgs:\n\nschedule::OperatingSchedule\n[OPTIONAL] t0::Vector{Int}: default = zeros(Int,nv(schedule))\n[OPTIONAL] tF::Vector{Int}: default = zeros(Int,nv(schedule))\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}","page":"API Reference","title":"TaskGraphs.prune_project_schedule","text":"`prune_project_schedule`\n\nRemove all vertices that have already been completed. The idea is to identify all Operations that are completed before t, remove all nodes upstream of them (except for ROBOTAT nodes), and create new edges between the ROBOTAT nodes and their first GO assignments.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.prune_schedule-Tuple{OperatingSchedule,ProblemSpec,Any}","page":"API Reference","title":"TaskGraphs.prune_schedule","text":"prune_schedule(sched::OperatingSchedule,\n    problem_spec::ProblemSpec,t)\n\nremove nodes that don't need to be kept around any longer\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.random_pctapf_def-Tuple{GraphUtils.GridFactoryEnvironment,Any}","page":"API Reference","title":"TaskGraphs.random_pctapf_def","text":"instantiate_random_pctapf_def(env,config)\n\nInstantiate a random PC_TAPF problem based on the parameters of config.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.random_pctapf_sequence-Tuple{GraphUtils.GridFactoryEnvironment,Any}","page":"API Reference","title":"TaskGraphs.random_pctapf_sequence","text":"instantiate_random_repeated_pctapf_problem(env,config)\n\nInstantiate a random RepeatedPC_TAPF problem based on the parameters of config.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.regenerate_path_specs!-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.regenerate_path_specs!","text":"regenerate_path_specs!(solver,env)\n\nRecompute all paths specs (to account for changes in the env_graphs that will be propagated to the ProblemSpec's distance function as well.)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.replace_in_schedule!","page":"API Reference","title":"TaskGraphs.replace_in_schedule!","text":"replace_in_schedule!(schedule::OperatingSchedule,path_spec::T,pred,id::ID) where {T<:PathSpec,ID<:AbstractID}\n\nReplace the ScheduleNode associated with id with the new node pred, and the accompanying PathSpec path_spec.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.replanning_config_1-Tuple{}","page":"API Reference","title":"TaskGraphs.replanning_config_1","text":"replanning_config_1\n\nReturns a vector of config dictionaries, which can be used to generate random problem instances for profiling.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.replanning_problem-NTuple{4,Any}","page":"API Reference","title":"TaskGraphs.replanning_problem","text":"replanning_problem\n\nConstructs a replanning problem, consisting of robot initial conditions, an environment, and a sequence of project requests scheduled to arrive in the factory at regular intervals. Args:\n\nr0: list of integers specifying the start locations of the robots\ndefs: a list of tuples, where each tuple is of the form\n([start_1=>goal_1, ...], [([inputs],[outputs]),...])\nwhere the start=>goal pairs define the start and end points for each   object to be delivered, and the ([inputs],[outputs]) pairs define the   objects that go in and out of each operation.\nenv_graph: the environment (presumably a GridFactoryEnvironment)\n\nOutputs:\n\nrequests: a sequence of ProjectRequests\nproblem_spec: a ProblemSpec\nrobotICs: Robot initial conditions `ROBOTAT`\nenv_graph: the environment\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.replanning_problem_3-Tuple{Any}","page":"API Reference","title":"TaskGraphs.replanning_problem_3","text":"The robot should do better if it handles the single task in the second\nproject prior to working on the third task of the first project.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.replanning_problem_4-Tuple{Any}","page":"API Reference","title":"TaskGraphs.replanning_problem_4","text":"Just intended to take longer so that the tests pass even if Julia hasn't\nfinished warming up yet.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.reset_cache!-Tuple{PlanningCache,OperatingSchedule}","page":"API Reference","title":"TaskGraphs.reset_cache!","text":"`reset_cache!(cache,sched)`\n\nResets the cache so that a solution can be repaired (otherwise calling\nlow_level_search!() will return immediately because the cache says it's\ncomplete)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N,Any}} where N<:ConstraintTreeNode","page":"API Reference","title":"TaskGraphs.reset_route_plan!","text":"Helper to reset the solution in a constraint node between re-runs of ISPS\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.resources_reserved-Tuple{Any}","page":"API Reference","title":"TaskGraphs.resources_reserved","text":"resources_reserved(node)\n\nIdentifies the resources reserved by a particular node for its duration. For example, resources_reserved(node::COLLECT) = AbstractID[get_location_id(node)]\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.robot_ids_match-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.robot_ids_match","text":"robot_ids_match(node,node2)\n\nChecks if robot_ids match between the nodes\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.robot_tip_map","page":"API Reference","title":"TaskGraphs.robot_tip_map","text":"robot_tip_map(sched::OperatingSchedule)\n\nReturns a Dict{RobotID,AbstractID} mapping RobotID to the terminal node of the sched corresponding to the robot's last assigned task.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.select_next_edges-NTuple{4,Any}","page":"API Reference","title":"TaskGraphs.select_next_edges","text":"Identifies the nodes v ∈ Ai and v2 ∈ Ao with the shortest distance D[v,v2].\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.set_default_milp_optimizer!-Tuple{Any}","page":"API Reference","title":"TaskGraphs.set_default_milp_optimizer!","text":"set_default_milp_optimizer!(optimizer)\n\nSet the black box optimizer to be use when formulating JuMP models.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair,Vararg{Any,N} where N}","page":"API Reference","title":"TaskGraphs.set_default_optimizer_attributes!","text":"set_default_optimizer_attributes!(vals)\n\nSet default optimizer attributes. e.g. set_default_optimizer_attributes!(Dict(\"PreSolve\"=>-1))\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver,Any,Any}","page":"API Reference","title":"TaskGraphs.solve_assignment_problem!","text":"solve_assignment_problem!(solver,model,prob)\n\nSolve the \"assignment problem\"–i.e., the relaxation of the full PC-TAPF problem wherein we ignore collisions–using the algorithm encoded by solver.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P,P}, Tuple{P,P,Any}} where P<:OperatingSchedule","page":"API Reference","title":"TaskGraphs.splice_schedules!","text":"splice_schedules!(sched::P,next_sched::P) where {P<:OperatingSchedule}\n\nMerge next_sched into sched\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule,ProblemSpec,Any}","page":"API Reference","title":"TaskGraphs.split_active_vtxs!","text":"split_active_vtxs!(sched::OperatingSchedule,\n    problem_spec::ProblemSpec,t;\n\nSplit all GO nodes that \"straddle\" the cutoff time.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.split_node","page":"API Reference","title":"TaskGraphs.split_node","text":"split_node(node::N,x::LocationID)\n\nCreates two new nodes of type N, where the destination of the first node and the starting location of the second node are both set to x.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.stitch_disjoint_node_sets!-NTuple{4,Any}","page":"API Reference","title":"TaskGraphs.stitch_disjoint_node_sets!","text":"stitch_disjoint_node_sets!(sched,incoming,outgoing)\n\nFinds and adds the appropriate edges between two sets of nodes. It is assumed that size(incoming) == size(outgoing), that each node in incoming has exactly one feasible successor in outgoing, and that each node in outgoing has exactly one feasible predecessor in incoming.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.tighten_gaps!-Tuple{Any,AbstractPC_MAPF,SearchEnv,ConstraintTreeNode}","page":"API Reference","title":"TaskGraphs.tighten_gaps!","text":"tighten_gaps!(solver, pc_mapf, env::SearchEnv, constraint_node::ConstraintTreeNode)\n\nIf any path ends before it should (based on times stored in get_cache(env)), recomputes the path segment for the final node in that line.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.trim_route_plan-Tuple{Any,Any,Any}","page":"API Reference","title":"TaskGraphs.trim_route_plan","text":"trim_route_plan(search_env, route_plan, T)\n\nConstruct a trimmed route_plan that stops at a certain time step\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any,T,Any}} where T<:TaskGraphsMILP","page":"API Reference","title":"TaskGraphs.update_assignment_problem!","text":"update_assignment_problem!(solver, assignment_problem)\n\nA helper method for updating an instance of an assignment problem. In the case     of MILP-based models, this method simply excludes all previous solutions by     adding new constraints on the assignment/adjacency matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any,SearchEnv,Int64,P}, Tuple{Any,SearchEnv,Int64,P,Any}} where P<:Path","page":"API Reference","title":"TaskGraphs.update_env!","text":"`update_env!`\n\n`v` is the vertex id\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.update_planning_cache!-Tuple{Any,Any}","page":"API Reference","title":"TaskGraphs.update_planning_cache!","text":"update_planning_cache!(solver,env)\n\nUpdate cache continually. After a call to this function, the start and end times of all schedule nodes will be updated to reflect the progress of active schedule nodes (i.e., if a robot had not yet completed a GO task, the predicted final time for that task will be updated based on the robot's current state and distance to the goal). All active nodes that don't require planning will be automatically marked as complete.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.update_planning_cache!-Tuple{Any,SearchEnv,Int64,Path}","page":"API Reference","title":"TaskGraphs.update_planning_cache!","text":"update_planning_cache!(solver,env,v,path)\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.update_project_schedule!","page":"API Reference","title":"TaskGraphs.update_project_schedule!","text":"update_project_schedule!(solver,milp_model::M,sched,problem_spec,\n    adj_matrix) where {M<:TaskGraphsMILP}\n\nArgs:\n\nmilp_model <: TaskGraphsMILP\nsched::OperatingSchedule\nproblem_spec::ProblemSpec\nadjmatrix : an adjacencymatrix or (in the case where   milp_model::AssignmentMILP), an assignment matrix\n\nAdds all required edges to the schedule graph and modifies all nodes to reflect the appropriate valid IDs (e.g., Action nodes are populated with the correct RobotIDs) Returns false if the new edges cause cycles in the project graph.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.update_project_schedule!-Tuple{Any,OperatingSchedule,Any,Any}","page":"API Reference","title":"TaskGraphs.update_project_schedule!","text":"update_project_schedule!\n\nArgs:\n\nsolver\nsched\nadjmatrix - adjacencymatrix encoding the edges that need to be added to   the project schedule\n\nAdds all required edges to the project graph and modifies all nodes to reflect the appropriate valid IDs (e.g., Action nodes are populated with the correct RobotIDs) Returns false if the new edges cause cycles in the project graph.\n\n\n\n\n\n","category":"method"},{"location":"reference/#TaskGraphs.update_route_plan!","page":"API Reference","title":"TaskGraphs.update_route_plan!","text":"update_route_plan!()\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.warmup","page":"API Reference","title":"TaskGraphs.warmup","text":"warmup(loader::TaskGraphsProblemLoader,solver_config,problem_dir,dummy_path = \"dummy_path\")\n\nDo a small dry run of run_profiling(loader,solver_config,problem_dir) to  ensure that all code is fully compiled before collecting results.\n\n\n\n\n\n","category":"function"},{"location":"reference/#TaskGraphs.write_problem","page":"API Reference","title":"TaskGraphs.write_problem","text":"write_problem(loader::TaskGraphsProblemLoader,problem_def,prob_path,env_id=\"\")\n\nWrite a problem that can later be loaded and solved.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TaskGraphs","category":"page"},{"location":"#TaskGraphs","page":"Home","title":"TaskGraphs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is for modeling and solving precedence-constrained multi agent task  assignment and path planning problems.","category":"page"},{"location":"#Where-to-begin?","page":"Home","title":"Where to begin?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"getting_started.md\"]\nDepth = 2","category":"page"},{"location":"#Profiling-Solver-Performance","page":"Home","title":"Profiling Solver Performance","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"profiling.md\"]\nDepth = 2","category":"page"},{"location":"#Core-Types","page":"Home","title":"Core Types","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]\nDepth = 2","category":"page"},{"location":"#API-Reference","page":"Home","title":"API Reference","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"reference.md\"]\nDepth = 2","category":"page"},{"location":"profiling/#Profiling","page":"Profiling","title":"Profiling","text":"","category":"section"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"To run the suite of experiments described in the ICRA paper,  run the script below (if you wish to use Gurobi,  you'll need to obtain a license and install Gurobi.jl.","category":"page"},{"location":"profiling/","page":"Profiling","title":"Profiling","text":"# copied from TaskGraphs/scripts/icra_experiments.jl\nusing TaskGraphs \n# NOTE that the experiments described in \"Optimal Sequential Task Assignment and \n# Path Finding for Multi-Agent Robotic Assembly Planning\", Brown et al. \n# were performed using Gurobi as the black box MILP solver. To use the default\n# (GLPK), simply comment out the following two lines.\nusing Gurobi\nset_default_milp_optimizer!(Gurobi.Optimizer)\n\n## ICRA experiments\n# You may want to redefine base_dir\n# -------------------------- #\nbase_dir            = joinpath(\"/scratch/task_graphs_experiments\")\n# -------------------------- #\nproblem_dir         = joinpath(base_dir,\"pctapf_problem_instances\")\nbase_results_path   = joinpath(base_dir,\"pctapf_results\")\n\nfeats = [\n    RunTime(),\n    FeasibleFlag(),\n    OptimalFlag(),\n    OptimalityGap(),\n    SolutionCost(),\n    PrimaryCost(),\n    SolutionAdjacencyMatrix(),\n]\nsolver_configs = [\n    (\n        solver = NBSSolver(\n            assignment_model = TaskGraphsMILPSolver(AssignmentMILP()),\n            path_planner = CBSSolver(ISPS()),\n            ),\n        results_path = joinpath(base_results_path,\"AssignmentMILP\"),\n        feats = feats,\n        objective = MakeSpan(),\n    ),\n]\n\nbase_config = Dict(\n    :env_id => \"env_2\",\n    :num_trials => 16,\n    :max_parents => 3,\n    :depth_bias => 0.4,\n    :dt_min => 0,\n    :dt_max => 0,\n    :dt_collect => 0,\n    :dt_deliver => 0,\n)\nsize_configs = [Dict(:M => m, :N => n) for (n,m) in Base.Iterators.product(\n    [10,20,30,40],[10,20,30,40,50,60]\n)][:]\nproblem_configs = map(d->merge(d,base_config), size_configs)\n\n# loader = PCTA_Loader() # to test task assignment only\nloader = PCTAPF_Loader()\nadd_env!(loader,\"env_2\",init_env_2())\nwrite_problems!(loader,problem_configs,problem_dir)\nfor solver_config in solver_configs\n    set_runtime_limit!(solver_config.solver,100)\n    warmup(loader,solver_config,problem_dir)\n    run_profiling(loader,solver_config,problem_dir)\nend","category":"page"}]
}
