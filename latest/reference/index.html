<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · TaskGraphs.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TaskGraphs.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../getting_started/">Getting Started</a></li><li><a class="tocitem" href="../profiling/">Profiling</a></li><li><a class="tocitem" href="../library/">Core Types and Methods</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Docs"><span>Docs</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sisl/TaskGraphs.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TaskGraphs.GADGET_EDGE_MULTIPLIER"><code>TaskGraphs.GADGET_EDGE_MULTIPLIER</code></a></li><li><a href="../library/#TaskGraphs.AStarSC"><code>TaskGraphs.AStarSC</code></a></li><li><a href="#TaskGraphs.AbstractPCTAPFSolver"><code>TaskGraphs.AbstractPCTAPFSolver</code></a></li><li><a href="../library/#TaskGraphs.AbstractPC_MAPF"><code>TaskGraphs.AbstractPC_MAPF</code></a></li><li><a href="../library/#TaskGraphs.AbstractPC_TAPF"><code>TaskGraphs.AbstractPC_TAPF</code></a></li><li><a href="../library/#TaskGraphs.AssignmentMILP"><code>TaskGraphs.AssignmentMILP</code></a></li><li><a href="../library/#TaskGraphs.BOT_AT"><code>TaskGraphs.BOT_AT</code></a></li><li><a href="#TaskGraphs.BOT_CARRY"><code>TaskGraphs.BOT_CARRY</code></a></li><li><a href="../library/#TaskGraphs.BOT_COLLECT"><code>TaskGraphs.BOT_COLLECT</code></a></li><li><a href="../library/#TaskGraphs.BOT_DEPOSIT"><code>TaskGraphs.BOT_DEPOSIT</code></a></li><li><a href="#TaskGraphs.BOT_GO"><code>TaskGraphs.BOT_GO</code></a></li><li><a href="#TaskGraphs.CLEAN_UP"><code>TaskGraphs.CLEAN_UP</code></a></li><li><a href="../library/#TaskGraphs.C_PC_MAPF"><code>TaskGraphs.C_PC_MAPF</code></a></li><li><a href="../library/#TaskGraphs.C_PC_TAPF"><code>TaskGraphs.C_PC_TAPF</code></a></li><li><a href="#TaskGraphs.CleanUpBot"><code>TaskGraphs.CleanUpBot</code></a></li><li><a href="../library/#TaskGraphs.ConstrainedMergeAndBalance"><code>TaskGraphs.ConstrainedMergeAndBalance</code></a></li><li><a href="#TaskGraphs.DeadRobot"><code>TaskGraphs.DeadRobot</code></a></li><li><a href="../library/#TaskGraphs.DeferUntilCompletion"><code>TaskGraphs.DeferUntilCompletion</code></a></li><li><a href="#TaskGraphs.DelayedRobot"><code>TaskGraphs.DelayedRobot</code></a></li><li><a href="#TaskGraphs.DroppedObject"><code>TaskGraphs.DroppedObject</code></a></li><li><a href="../library/#TaskGraphs.EnvState"><code>TaskGraphs.EnvState</code></a></li><li><a href="../library/#TaskGraphs.FullReplanner"><code>TaskGraphs.FullReplanner</code></a></li><li><a href="#TaskGraphs.GadgetGraph"><code>TaskGraphs.GadgetGraph</code></a></li><li><a href="../library/#TaskGraphs.GreedyAssignment"><code>TaskGraphs.GreedyAssignment</code></a></li><li><a href="../library/#TaskGraphs.ISPS"><code>TaskGraphs.ISPS</code></a></li><li><a href="#TaskGraphs.Intruder"><code>TaskGraphs.Intruder</code></a></li><li><a href="../library/#TaskGraphs.MergeAndBalance"><code>TaskGraphs.MergeAndBalance</code></a></li><li><a href="../library/#TaskGraphs.NBSSolver"><code>TaskGraphs.NBSSolver</code></a></li><li><a href="../library/#TaskGraphs.OBJECT_AT"><code>TaskGraphs.OBJECT_AT</code></a></li><li><a href="#TaskGraphs.OilSpill"><code>TaskGraphs.OilSpill</code></a></li><li><a href="../library/#TaskGraphs.OperatingSchedule"><code>TaskGraphs.OperatingSchedule</code></a></li><li><a href="#TaskGraphs.Operation"><code>TaskGraphs.Operation</code></a></li><li><a href="../library/#TaskGraphs.PC_MAPF"><code>TaskGraphs.PC_MAPF</code></a></li><li><a href="../library/#TaskGraphs.PC_TA"><code>TaskGraphs.PC_TA</code></a></li><li><a href="../library/#TaskGraphs.PC_TAPF"><code>TaskGraphs.PC_TAPF</code></a></li><li><a href="#TaskGraphs.PathSpec"><code>TaskGraphs.PathSpec</code></a></li><li><a href="#TaskGraphs.PrioritizedAStarSC"><code>TaskGraphs.PrioritizedAStarSC</code></a></li><li><a href="../library/#TaskGraphs.ProblemSpec"><code>TaskGraphs.ProblemSpec</code></a></li><li><a href="../library/#TaskGraphs.ProjectRequest"><code>TaskGraphs.ProjectRequest</code></a></li><li><a href="../library/#TaskGraphs.ProjectSpec"><code>TaskGraphs.ProjectSpec</code></a></li><li><a href="../library/#TaskGraphs.ReassignFreeRobots"><code>TaskGraphs.ReassignFreeRobots</code></a></li><li><a href="../library/#TaskGraphs.RepeatedPC_TAPF"><code>TaskGraphs.RepeatedPC_TAPF</code></a></li><li><a href="../library/#TaskGraphs.ReplannerConfig"><code>TaskGraphs.ReplannerConfig</code></a></li><li><a href="../library/#TaskGraphs.ReplannerModel"><code>TaskGraphs.ReplannerModel</code></a></li><li><a href="../library/#TaskGraphs.ReplannerWithBackup"><code>TaskGraphs.ReplannerWithBackup</code></a></li><li><a href="../library/#TaskGraphs.ReplanningProfilerCache"><code>TaskGraphs.ReplanningProfilerCache</code></a></li><li><a href="../library/#TaskGraphs.ScheduleNode"><code>TaskGraphs.ScheduleNode</code></a></li><li><a href="../library/#TaskGraphs.SearchEnv"><code>TaskGraphs.SearchEnv</code></a></li><li><a href="#TaskGraphs.SimpleRepeatedProblemDef"><code>TaskGraphs.SimpleRepeatedProblemDef</code></a></li><li><a href="#TaskGraphs.SimpleReplanningRequest"><code>TaskGraphs.SimpleReplanningRequest</code></a></li><li><a href="../library/#TaskGraphs.SparseAdjacencyMILP"><code>TaskGraphs.SparseAdjacencyMILP</code></a></li><li><a href="#TaskGraphs.StochasticProblem"><code>TaskGraphs.StochasticProblem</code></a></li><li><a href="../library/#TaskGraphs.TEAM_ACTION"><code>TaskGraphs.TEAM_ACTION</code></a></li><li><a href="../library/#TaskGraphs.TaskGraphsMILP"><code>TaskGraphs.TaskGraphsMILP</code></a></li><li><a href="../library/#TaskGraphs.TaskGraphsMILPSolver"><code>TaskGraphs.TaskGraphsMILPSolver</code></a></li><li><a href="../library/#TaskGraphs.TaskGraphsProblemLoader"><code>TaskGraphs.TaskGraphsProblemLoader</code></a></li><li><a href="#TaskGraphs.TeamAssignmentMILP"><code>TaskGraphs.TeamAssignmentMILP</code></a></li><li><a href="#TaskGraphs.UNDERTAKE"><code>TaskGraphs.UNDERTAKE</code></a></li><li><a href="#CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any, C_PC_MAPF, E, N, T, Int64}} where {E&lt;:SearchEnv, N&lt;:ConstraintTreeNode, T}"><code>CRCBS.build_env</code></a></li><li><a href="../library/#CRCBS.load_problem"><code>CRCBS.load_problem</code></a></li><li><a href="#CRCBS.load_problem-Tuple{TaskGraphsProblemLoader, Any, Any}"><code>CRCBS.load_problem</code></a></li><li><a href="#CRCBS.pibt_update_solution!-Tuple{Any, SearchEnv, Any}"><code>CRCBS.pibt_update_solution!</code></a></li><li><a href="#CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader, Any, Any}"><code>CRCBS.run_profiling</code></a></li><li><a href="../library/#CRCBS.run_profiling"><code>CRCBS.run_profiling</code></a></li><li><a href="#CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver, E}} where E&lt;:AbstractPC_TAPF"><code>CRCBS.solve!</code></a></li><li><a href="#JuMP.optimize!-Tuple{GreedyAssignment}"><code>JuMP.optimize!</code></a></li><li><a href="#TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP, OperatingSchedule, ProblemSpec}"><code>TaskGraphs.add_job_shop_constraints!</code></a></li><li><a href="#TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph, Any}"><code>TaskGraphs.add_movement_vtx!</code></a></li><li><a href="#TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule, Any}"><code>TaskGraphs.adj_mat_from_assignment_mat</code></a></li><li><a href="#TaskGraphs.align_with_predecessor-Tuple{Any, Any}"><code>TaskGraphs.align_with_predecessor</code></a></li><li><a href="#TaskGraphs.align_with_successor-Tuple{Any, Any}"><code>TaskGraphs.align_with_successor</code></a></li><li><a href="#TaskGraphs.backtrack_node-Tuple{OperatingSchedule, Int64}"><code>TaskGraphs.backtrack_node</code></a></li><li><a href="#TaskGraphs.break_assignments!-Tuple{OperatingSchedule, ProblemSpec}"><code>TaskGraphs.break_assignments!</code></a></li><li><a href="#TaskGraphs.check_object_id-Tuple{Any, Any}"><code>TaskGraphs.check_object_id</code></a></li><li><a href="#TaskGraphs.choose_random_object_sizes-Tuple{Any, Dict{Tuple{Int64, Int64}, Float64}}"><code>TaskGraphs.choose_random_object_sizes</code></a></li><li><a href="#TaskGraphs.clear_default_optimizer_attributes!-Tuple{}"><code>TaskGraphs.clear_default_optimizer_attributes!</code></a></li><li><a href="#TaskGraphs.compute_lower_bound"><code>TaskGraphs.compute_lower_bound</code></a></li><li><a href="#TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS, AbstractPC_MAPF, N}, Tuple{ISPS, AbstractPC_MAPF, N, SearchEnv}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.compute_route_plan!</code></a></li><li><a href="#TaskGraphs.construct_cost_model"><code>TaskGraphs.construct_cost_model</code></a></li><li><a href="#TaskGraphs.construct_heuristic_model"><code>TaskGraphs.construct_heuristic_model</code></a></li><li><a href="#TaskGraphs.construct_operation"><code>TaskGraphs.construct_operation</code></a></li><li><a href="#TaskGraphs.construct_partial_project_schedule"><code>TaskGraphs.construct_partial_project_schedule</code></a></li><li><a href="#TaskGraphs.construct_random_project_spec-Tuple{Int64, Vector{OBJECT_AT}, Vector{OBJECT_AT}}"><code>TaskGraphs.construct_random_project_spec</code></a></li><li><a href="#TaskGraphs.construct_random_task_graphs_problem"><code>TaskGraphs.construct_random_task_graphs_problem</code></a></li><li><a href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a></li><li><a href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a></li><li><a href="#TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec, Vector{Int64}, Vector{Int64}, Vector{Int64}, Any}"><code>TaskGraphs.construct_task_graphs_problem</code></a></li><li><a href="#TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}"><code>TaskGraphs.convert_env_graph_to_undirected</code></a></li><li><a href="#TaskGraphs.default_milp_optimizer-Tuple{}"><code>TaskGraphs.default_milp_optimizer</code></a></li><li><a href="#TaskGraphs.default_optimizer_attributes-Tuple{}"><code>TaskGraphs.default_optimizer_attributes</code></a></li><li><a href="#TaskGraphs.evaluate_path_gap-Tuple{SearchEnv, Any, Any}"><code>TaskGraphs.evaluate_path_gap</code></a></li><li><a href="#TaskGraphs.exclude_solutions!-Tuple{JuMP.Model, Matrix{Int64}}"><code>TaskGraphs.exclude_solutions!</code></a></li><li><a href="#TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.fix_precutoff_nodes!</code></a></li><li><a href="#TaskGraphs.formulate_assignment_problem-Tuple{Any, Any}"><code>TaskGraphs.formulate_assignment_problem</code></a></li><li><a href="#TaskGraphs.formulate_big_milp"><code>TaskGraphs.formulate_big_milp</code></a></li><li><a href="#TaskGraphs.formulate_milp-Tuple{AssignmentMILP, OperatingSchedule, ProblemSpec}"><code>TaskGraphs.formulate_milp</code></a></li><li><a href="../library/#TaskGraphs.formulate_milp"><code>TaskGraphs.formulate_milp</code></a></li><li><a href="#TaskGraphs.generate_path_spec-Tuple{ProblemSpec, Any}"><code>TaskGraphs.generate_path_spec</code></a></li><li><a href="#TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule, Any}"><code>TaskGraphs.get_active_and_fixed_vtxs</code></a></li><li><a href="#TaskGraphs.get_assignment_dict-Tuple{Any, Any, Any}"><code>TaskGraphs.get_assignment_dict</code></a></li><li><a href="#TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule, ObjectID}"><code>TaskGraphs.get_delivery_task_vtxs</code></a></li><li><a href="#TaskGraphs.get_duration_vector-Tuple{ProjectSpec}"><code>TaskGraphs.get_duration_vector</code></a></li><li><a href="#TaskGraphs.get_env_snapshot-Tuple{SearchEnv, Any}"><code>TaskGraphs.get_env_snapshot</code></a></li><li><a href="#TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv, Any}"><code>TaskGraphs.get_next_node_matching_agent_id</code></a></li><li><a href="#TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv, Any}"><code>TaskGraphs.get_next_vtx_matching_agent_id</code></a></li><li><a href="#TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}"><code>TaskGraphs.get_node_start_and_end_times</code></a></li><li><a href="#TaskGraphs.get_objective_expr-Tuple{AssignmentMILP, SumOfMakeSpans}"><code>TaskGraphs.get_objective_expr</code></a></li><li><a href="#TaskGraphs.get_random_problem_instantiation-Tuple{Int64, Int64, Any, Any, Any}"><code>TaskGraphs.get_random_problem_instantiation</code></a></li><li><a href="#TaskGraphs.get_sF-Tuple{AssignmentMILP}"><code>TaskGraphs.get_sF</code></a></li><li><a href="#TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph, Any, Any}"><code>TaskGraphs.get_source_map</code></a></li><li><a href="#TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule, A}, Tuple{OperatingSchedule, A, Any}} where A&lt;:Union{ActionID, BotID}"><code>TaskGraphs.get_valid_robot_ids</code></a></li><li><a href="#TaskGraphs.handle_disturbance!"><code>TaskGraphs.handle_disturbance!</code></a></li><li><a href="#TaskGraphs.isolate_delivery_task_vtxs"><code>TaskGraphs.isolate_delivery_task_vtxs</code></a></li><li><a href="#TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A, Type{B}}} where {A, B}"><code>TaskGraphs.matches_node_type</code></a></li><li><a href="#TaskGraphs.pctapf_problem_1-Tuple{}"><code>TaskGraphs.pctapf_problem_1</code></a></li><li><a href="#TaskGraphs.pctapf_problem_10-Tuple{}"><code>TaskGraphs.pctapf_problem_10</code></a></li><li><a href="#TaskGraphs.pctapf_problem_11-Tuple{}"><code>TaskGraphs.pctapf_problem_11</code></a></li><li><a href="#TaskGraphs.pctapf_problem_12-Tuple{}"><code>TaskGraphs.pctapf_problem_12</code></a></li><li><a href="#TaskGraphs.pctapf_problem_13-Tuple{}"><code>TaskGraphs.pctapf_problem_13</code></a></li><li><a href="#TaskGraphs.pctapf_problem_2-Tuple{}"><code>TaskGraphs.pctapf_problem_2</code></a></li><li><a href="#TaskGraphs.pctapf_problem_3-Tuple{}"><code>TaskGraphs.pctapf_problem_3</code></a></li><li><a href="#TaskGraphs.pctapf_problem_4-Tuple{}"><code>TaskGraphs.pctapf_problem_4</code></a></li><li><a href="#TaskGraphs.pctapf_problem_5-Tuple{}"><code>TaskGraphs.pctapf_problem_5</code></a></li><li><a href="#TaskGraphs.pctapf_problem_6-Tuple{}"><code>TaskGraphs.pctapf_problem_6</code></a></li><li><a href="#TaskGraphs.pctapf_problem_7-Tuple{}"><code>TaskGraphs.pctapf_problem_7</code></a></li><li><a href="#TaskGraphs.pctapf_problem_8-Tuple{}"><code>TaskGraphs.pctapf_problem_8</code></a></li><li><a href="#TaskGraphs.pctapf_problem_9-Tuple{}"><code>TaskGraphs.pctapf_problem_9</code></a></li><li><a href="#TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS, AbstractPC_MAPF, SearchEnv, N}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.plan_next_path!</code></a></li><li><a href="#TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC, AbstractPC_MAPF, SearchEnv, N, T, Int64}} where {N&lt;:ConstraintTreeNode, T}"><code>TaskGraphs.plan_path!</code></a></li><li><a href="#TaskGraphs.plan_route!-Tuple{Any, Any, Any}"><code>TaskGraphs.plan_route!</code></a></li><li><a href="#TaskGraphs.post_process_replanning_results!-Tuple{Any, Any}"><code>TaskGraphs.post_process_replanning_results!</code></a></li><li><a href="#TaskGraphs.preprocess_project_schedule-Tuple{Any}"><code>TaskGraphs.preprocess_project_schedule</code></a></li><li><a href="#TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P, Any}, Tuple{P, Any, Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.process_schedule</code></a></li><li><a href="#TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.prune_project_schedule</code></a></li><li><a href="#TaskGraphs.prune_schedule-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.prune_schedule</code></a></li><li><a href="#TaskGraphs.random_pctapf_def-Tuple{GridFactoryEnvironment, Any}"><code>TaskGraphs.random_pctapf_def</code></a></li><li><a href="#TaskGraphs.random_pctapf_sequence-Tuple{GridFactoryEnvironment, Any}"><code>TaskGraphs.random_pctapf_sequence</code></a></li><li><a href="#TaskGraphs.regenerate_path_specs!-Tuple{Any, Any}"><code>TaskGraphs.regenerate_path_specs!</code></a></li><li><a href="#TaskGraphs.replace_in_schedule!"><code>TaskGraphs.replace_in_schedule!</code></a></li><li><a href="#TaskGraphs.replanning_config_1-Tuple{}"><code>TaskGraphs.replanning_config_1</code></a></li><li><a href="#TaskGraphs.replanning_problem-NTuple{4, Any}"><code>TaskGraphs.replanning_problem</code></a></li><li><a href="#TaskGraphs.replanning_problem_3-Tuple{Any}"><code>TaskGraphs.replanning_problem_3</code></a></li><li><a href="#TaskGraphs.replanning_problem_4-Tuple{Any}"><code>TaskGraphs.replanning_problem_4</code></a></li><li><a href="#TaskGraphs.reset_cache!-Tuple{PlanningCache, OperatingSchedule}"><code>TaskGraphs.reset_cache!</code></a></li><li><a href="#TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N, Any}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.reset_route_plan!</code></a></li><li><a href="#TaskGraphs.resources_reserved-Tuple{Any}"><code>TaskGraphs.resources_reserved</code></a></li><li><a href="#TaskGraphs.robot_ids_match-Tuple{Any, Any}"><code>TaskGraphs.robot_ids_match</code></a></li><li><a href="#TaskGraphs.robot_tip_map"><code>TaskGraphs.robot_tip_map</code></a></li><li><a href="#TaskGraphs.select_next_edges-NTuple{4, Any}"><code>TaskGraphs.select_next_edges</code></a></li><li><a href="#TaskGraphs.set_default_milp_optimizer!-Tuple{Any}"><code>TaskGraphs.set_default_milp_optimizer!</code></a></li><li><a href="#TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair, Vararg{Any}}"><code>TaskGraphs.set_default_optimizer_attributes!</code></a></li><li><a href="#TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver, Any, Any}"><code>TaskGraphs.solve_assignment_problem!</code></a></li><li><a href="#TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P, P}, Tuple{P, P, Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.splice_schedules!</code></a></li><li><a href="#TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.split_active_vtxs!</code></a></li><li><a href="#TaskGraphs.split_node"><code>TaskGraphs.split_node</code></a></li><li><a href="#TaskGraphs.stitch_disjoint_node_sets!-NTuple{4, Any}"><code>TaskGraphs.stitch_disjoint_node_sets!</code></a></li><li><a href="#TaskGraphs.tighten_gaps!-Tuple{Any, AbstractPC_MAPF, SearchEnv, ConstraintTreeNode}"><code>TaskGraphs.tighten_gaps!</code></a></li><li><a href="#TaskGraphs.trim_route_plan-Tuple{Any, Any, Any}"><code>TaskGraphs.trim_route_plan</code></a></li><li><a href="#TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:TaskGraphsMILP"><code>TaskGraphs.update_assignment_problem!</code></a></li><li><a href="#TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any, SearchEnv, Int64, P}, Tuple{Any, SearchEnv, Int64, P, Any}} where P&lt;:Path"><code>TaskGraphs.update_env!</code></a></li><li><a href="#TaskGraphs.update_planning_cache!-Tuple{Any, Any}"><code>TaskGraphs.update_planning_cache!</code></a></li><li><a href="#TaskGraphs.update_planning_cache!-Tuple{Any, SearchEnv, Int64, Path}"><code>TaskGraphs.update_planning_cache!</code></a></li><li><a href="#TaskGraphs.update_project_schedule!-Tuple{Any, OperatingSchedule, Any, Any}"><code>TaskGraphs.update_project_schedule!</code></a></li><li><a href="#TaskGraphs.update_project_schedule!"><code>TaskGraphs.update_project_schedule!</code></a></li><li><a href="#TaskGraphs.update_route_plan!"><code>TaskGraphs.update_route_plan!</code></a></li><li><a href="#TaskGraphs.warmup"><code>TaskGraphs.warmup</code></a></li><li><a href="../library/#TaskGraphs.warmup"><code>TaskGraphs.warmup</code></a></li><li><a href="#TaskGraphs.write_problem"><code>TaskGraphs.write_problem</code></a></li><li><a href="../library/#TaskGraphs.write_problem"><code>TaskGraphs.write_problem</code></a></li></ul><h2 id="Docs"><a class="docs-heading-anchor" href="#Docs">Docs</a><a id="Docs-1"></a><a class="docs-heading-anchor-permalink" href="#Docs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.GADGET_EDGE_MULTIPLIER" href="#TaskGraphs.GADGET_EDGE_MULTIPLIER"><code>TaskGraphs.GADGET_EDGE_MULTIPLIER</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">The number of edges in each &quot;gadget&quot; per original edge</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/milp_formulation.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.AbstractPCTAPFSolver" href="#TaskGraphs.AbstractPCTAPFSolver"><code>TaskGraphs.AbstractPCTAPFSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPCTAPFSolver</code></pre><p>Abstract type of which all PC-TAPF solvers must be concrete subtypes. All concrete solvers must implement the following interface for solving PC-TAPF problems:</p><ul><li><code>solution, cost = solve!(solver,problem_def)</code></li><li><code>check_runtime(solver)</code> should trigger an interrupt + early return if the   allowable runtime has been exceeded</li></ul><p>Also, we need a good Logger type for keeping track of thing like runtime, iterations, optimality gap (including upper and lower bound), etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L11-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.BOT_CARRY" href="#TaskGraphs.BOT_CARRY"><code>TaskGraphs.BOT_CARRY</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BOT_CARRY &lt;: AbstractRobotAction</code></pre><p>Encodes the event &quot;robot <code>r</code> carries object <code>o</code> from <code>x1</code> to <code>x2</code>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L301-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.BOT_GO" href="#TaskGraphs.BOT_GO"><code>TaskGraphs.BOT_GO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BOT_GO &lt;: AbstractRobotAction</code></pre><p>Encodes the event &quot;robot <code>r</code> goes from <code>x1</code> to <code>x2</code>&quot;</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L289-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.CLEAN_UP" href="#TaskGraphs.CLEAN_UP"><code>TaskGraphs.CLEAN_UP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CLEAN_UP &lt;: AbstractRobotAction</code></pre><p>Encodes the event &quot;robot <code>r</code> cleans up locations vtxs`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L367-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.CleanUpBot" href="#TaskGraphs.CleanUpBot"><code>TaskGraphs.CleanUpBot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CleanUpBot &lt;: AbstractRobotType</code></pre><p>A robot type for picking up dropped objects, cleaning up spills, and taking  care of dead robots</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L345-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.DeadRobot" href="#TaskGraphs.DeadRobot"><code>TaskGraphs.DeadRobot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DeadRobot</code></pre><p>Robot <code>id</code> is frozen.</p><p>Effect:</p><ul><li>Freeze robot</li><li>Add &quot;no-go&quot; constraint to CBS/PIBT (how to do consistently? Perhaps place in   SearchEnv and add directly to PCCBSEnv) OR temporarily remove vertex from   graph</li><li>Set robot state to NULL state? How to avoid having CBS complain about   conflicts? Maybe set State to NULL State and place DeadRobotObject at the   collection site?</li><li>Dispatch CleanUpBot to collect frozen robot</li><li>When CleanUpBot returns to &quot;garage&quot;, regenerate frozen Robot&#39;s ROBOT_AT node   and valid state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.DelayedRobot" href="#TaskGraphs.DelayedRobot"><code>TaskGraphs.DelayedRobot</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DelayedRobot</code></pre><p>Robot <code>id</code> is delayed by <code>dt</code> timesteps.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.DroppedObject" href="#TaskGraphs.DroppedObject"><code>TaskGraphs.DroppedObject</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DroppedObject</code></pre><p>Object <code>id</code> dropped.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.GadgetGraph" href="#TaskGraphs.GadgetGraph"><code>TaskGraphs.GadgetGraph</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GadgetGraph</code></pre><p>Represents a time-extended graph useful for MILP formulations</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/milp_formulation.jl#L21-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.Intruder" href="#TaskGraphs.Intruder"><code>TaskGraphs.Intruder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Intruder</code></pre><p>An intruder that begins at location <code>start_vtx</code> and follows policy <code>policy</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.OilSpill" href="#TaskGraphs.OilSpill"><code>TaskGraphs.OilSpill</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OilSpill</code></pre><p>An obstruction that affects vertices <code>vtxs</code> and edges <code>edges</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.Operation" href="#TaskGraphs.Operation"><code>TaskGraphs.Operation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Operation &lt;: AbstractPlanningPredicate</code></pre><p>A manufacturing operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L230-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.PathSpec" href="#TaskGraphs.PathSpec"><code>TaskGraphs.PathSpec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PathSpec</code></pre><p>Encodes information about the path that must be planned for a particular schedule node.</p><p>Fields:</p><ul><li><code>node_type::Symbol = :EMPTY</code></li><li><code>start_vtx::Int = -1</code></li><li><code>final_vtx::Int = -1</code></li><li><code>min_duration::Int = 0</code></li><li><code>agent_id::Int = -1</code></li><li><code>object_id::Int = -1</code></li><li><code>plan_path::Bool = true</code> - flag indicating whether a path must be planned.   For example, <code>Operation</code> nodes do not require any path planning.</li><li><code>tight::Bool = false</code> - if true, the path may not terminate prior to the   beginning of successors. If <code>tight == true</code>, local slack == 0. For example,   <code>GO</code> must not end before <code>COLLECT</code> can begin, because this would produce   empty time between planning phases.</li><li><code>static::Bool = false</code> - if true, the robot must remain in place for this   planning phase (e.g., COLLECT, DEPOSIT).</li><li><code>free::Bool = false</code> - if true, and if the node is a terminal node, the   planning must go on until all non-free nodes are completed.</li><li><code>fixed::Bool = false</code> - if true, do not plan path because it is already fixed.   Instead, retrieve the portion of the path directly from the pre-existing   solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L358-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.PrioritizedAStarSC" href="#TaskGraphs.PrioritizedAStarSC"><code>TaskGraphs.PrioritizedAStarSC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrioritizedAStarSC</code></pre><p>Low-level proritized path planner that employs Slack-and-Collision-Aware A*.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.SimpleRepeatedProblemDef" href="#TaskGraphs.SimpleRepeatedProblemDef"><code>TaskGraphs.SimpleRepeatedProblemDef</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleRepeatedProblemDef</code></pre><p>Intermediate representation of a <code>RepeatedPC_TAPF</code> (useful for I/O)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/experiments/replanning_experiments.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.SimpleReplanningRequest" href="#TaskGraphs.SimpleReplanningRequest"><code>TaskGraphs.SimpleReplanningRequest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SimpleReplanningRequest</code></pre><p>Intermediate representation of a <code>ProjectRequest</code> (useful for I/O)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/experiments/replanning_experiments.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.StochasticProblem" href="#TaskGraphs.StochasticProblem"><code>TaskGraphs.StochasticProblem</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StochasticProblem{P&lt;:AbstractPC_TAPF}</code></pre><p>Defines a stochastic version of PC_TAPF, wherein different disturbances can cause unexpected problems in the factory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L13-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.TeamAssignmentMILP" href="#TaskGraphs.TeamAssignmentMILP"><code>TaskGraphs.TeamAssignmentMILP</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TeamAssignmentMILP</code></pre><p>***Not yet implemented.***</p><p>Eextend the assignment matrix formulation of <code>AssignmentMILP</code> to the &quot;team-forming&quot; case where robots must collaboratively transport some objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.UNDERTAKE" href="#TaskGraphs.UNDERTAKE"><code>TaskGraphs.UNDERTAKE</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UNDERTAKE &lt;: AbstractRobotAction{CleanUpBot}</code></pre><p>Encodes the task of collecting, carrying, and depositing a dead robot</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L377-L381">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any, C_PC_MAPF, E, N, T, Int64}} where {E&lt;:SearchEnv, N&lt;:ConstraintTreeNode, T}" href="#CRCBS.build_env-Union{Tuple{T}, Tuple{N}, Tuple{E}, Tuple{Any, C_PC_MAPF, E, N, T, Int64}} where {E&lt;:SearchEnv, N&lt;:ConstraintTreeNode, T}"><code>CRCBS.build_env</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">For COLLABORATIVE transport problems</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L890-L892">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.load_problem-Tuple{TaskGraphsProblemLoader, Any, Any}" href="#CRCBS.load_problem-Tuple{TaskGraphsProblemLoader, Any, Any}"><code>CRCBS.load_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRCBS.load_problem(loader::TaskGraphsProblemLoader,solver_config,prob_path)</code></pre><p>Currently only impemented for PC<em>TAPF and PC</em>TA</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/profiling.jl#L178-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.pibt_update_solution!-Tuple{Any, SearchEnv, Any}" href="#CRCBS.pibt_update_solution!-Tuple{Any, SearchEnv, Any}"><code>CRCBS.pibt_update_solution!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRCBS.pibt_update_solution!(solver,pc_mapf::PC_MAPF,solution::SearchEnv,cache)</code></pre><p>Overridden to update the SearchEnv</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planners/pibt_planner.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader, Any, Any}" href="#CRCBS.run_profiling-Tuple{TaskGraphsProblemLoader, Any, Any}"><code>CRCBS.run_profiling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CRCBS.run_profiling(loader::TaskGraphsProblemLoader,solver_config,problem_dir)</code></pre><p>Run profiling with a <code>TaskGraphsProblemLoader</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/profiling.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver, E}} where E&lt;:AbstractPC_TAPF" href="#CRCBS.solve!-Union{Tuple{E}, Tuple{NBSSolver, E}} where E&lt;:AbstractPC_TAPF"><code>CRCBS.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(solver, base_env::SearchEnv;kwargs...) where {A,P}</code></pre><p>Use the planner defined by <code>solver</code> to solve the PC-TAPF problem encoded by <code>base_env</code>. For solvers of type <code>NBSSolver</code>, the algorithm involves repeatedly solving an assignment problem followed by a route-planning problem. Within the generic <code>solve!</code> method it is possible to initialize an assignment problem (the type is not constrained) and then modify it via <code>update_assignment_problem!</code> prior to each new call to <code>solve_assignment_problem!</code>. This is the approach taken for various MILP-based assignment solvers. It is also possible to reconstruct the assignment problem from scratch within each call to <code>solve_assignment_problem!</code>.</p><p>Arguments:</p><ul><li>solver &lt;: AbstractPCTAPFSolver</li><li>base_env::SearchEnv : a PC-TAPF problem</li></ul><p>Outputs:</p><ul><li>best_env : a <code>SearchEnv</code> data structure that encodes a solution to the problem</li><li>cost : the cost of the solution encoded by <code>best_env</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L517-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="JuMP.optimize!-Tuple{GreedyAssignment}" href="#JuMP.optimize!-Tuple{GreedyAssignment}"><code>JuMP.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>GreedyAssignment maintains three sets: The &quot;satisfied set&quot; <code>C</code>, the &quot;required incoming&quot; set <code>Ai</code>, and the &quot;available outgoing&quot; set <code>Ao</code>.</p><p>At each step, the algorithm identifies the nodes <code>v1 ∈ Ai</code> and <code>v2 ∈ Ao</code> with shortest &quot;distance&quot; (in the context of <code>OperatingSchedule</code>s, this distance refers to the duration of <code>v1</code> if an edge <code>v1 → v2</code> is added) and adds an edge between them. The distance corresponding to an ineligible edge is set to Inf.</p><p>After adding the edge, the algorithm sweeps through a topological ordering of the vertices and updates <code>C</code>, <code>Ai</code>, and <code>Ao</code>. In order for <code>v</code> to be placed in <code>C</code>, <code>v</code> must have enough incoming edges and all of <code>v</code>&#39;s predecessors must already be in <code>C</code>. In order to be added to <code>Ai</code>, <code>v</code> must have less than the required number of incoming edges and all of <code>v</code>&#39;s predecessors must already be in <code>C</code>. In order for <code>v</code> to be added to <code>Ao</code>, <code>v</code> must have less than the allowable number of outgoing edges, and must be in <code>C</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L1234-L1250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP, OperatingSchedule, ProblemSpec}" href="#TaskGraphs.add_job_shop_constraints!-Tuple{AssignmentMILP, OperatingSchedule, ProblemSpec}"><code>TaskGraphs.add_job_shop_constraints!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_job_shop_constraints!(milp_model::AssignmentMILP,sched::OperatingSchedule,spec::ProblemSpec) #,model::JuMP.Model)</code></pre><p>After an <code>AssignmentMILP</code> has been optimized, add in any edges that result from an active ``job shop&#39;&#39; constraint (where two robots require the same resource).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L217-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph, Any}" href="#TaskGraphs.add_movement_vtx!-Tuple{TaskGraphs.GadgetGraph, Any}"><code>TaskGraphs.add_movement_vtx!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add_movement_vtx!</code></pre><p>Flags a vertex of the gadget graph as corresponding to a non-&quot;wait&quot; edge</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/milp_formulation.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule, Any}" href="#TaskGraphs.adj_mat_from_assignment_mat-Tuple{OperatingSchedule, Any}"><code>TaskGraphs.adj_mat_from_assignment_mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adj_mat_from_assignment_mat(sched,assignment_matrix)</code></pre><p>Compute an adjacency matrix from an assignment matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.align_with_predecessor-Tuple{Any, Any}" href="#TaskGraphs.align_with_predecessor-Tuple{Any, Any}"><code>TaskGraphs.align_with_predecessor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">align_with_predecessor(node,succ)</code></pre><p>Modifies a node to match the information encoded by its predecessor. This is how e.g., robot ids are propagated through an existing operating schedule after assignments (or re-assignments) have been made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L105-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.align_with_successor-Tuple{Any, Any}" href="#TaskGraphs.align_with_successor-Tuple{Any, Any}"><code>TaskGraphs.align_with_successor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">align_with_successor(node,succ)</code></pre><p>Modifies a node to match the information encoded by its successor. This is how e.g., robot ids are propagated through an existing operating schedule after assignments (or re-assignments) have been made.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.backtrack_node-Tuple{OperatingSchedule, Int64}" href="#TaskGraphs.backtrack_node-Tuple{OperatingSchedule, Int64}"><code>TaskGraphs.backtrack_node</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`backtrack_node(sched::OperatingSchedule,v::Int)`</code></pre><p>Find the closest ancestor of <code>v</code> with overlapping <code>RobotID</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L639-L643">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.break_assignments!-Tuple{OperatingSchedule, ProblemSpec}" href="#TaskGraphs.break_assignments!-Tuple{OperatingSchedule, ProblemSpec}"><code>TaskGraphs.break_assignments!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">break_assignments!(sched::OperatingSchedule,problem_spec::ProblemSpec)</code></pre><p>Break all assignments that are eligible for replanning</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.check_object_id-Tuple{Any, Any}" href="#TaskGraphs.check_object_id-Tuple{Any, Any}"><code>TaskGraphs.check_object_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Check if a node is associated with objectid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L61-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.choose_random_object_sizes-Tuple{Any, Dict{Tuple{Int64, Int64}, Float64}}" href="#TaskGraphs.choose_random_object_sizes-Tuple{Any, Dict{Tuple{Int64, Int64}, Float64}}"><code>TaskGraphs.choose_random_object_sizes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Tool for randomly selecting how many robots (and in what configuration)
    should deliver each task.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L306-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.clear_default_optimizer_attributes!-Tuple{}" href="#TaskGraphs.clear_default_optimizer_attributes!-Tuple{}"><code>TaskGraphs.clear_default_optimizer_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">clear_default_optimizer_attributes!()</code></pre><p>Clear the default optimizer attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/JuMP_interface.jl#L45-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.compute_lower_bound" href="#TaskGraphs.compute_lower_bound"><code>TaskGraphs.compute_lower_bound</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">compute_lower_bound(env,[starts,assigned,dist_mtx,pairs])</code></pre><p>Computes a lower bound on makespan for <code>sched::OperatingSchedule</code> by assuming     that any robot can be simultaneously assigned to multiple tasks.</p><p>Args:</p><ul><li><code>env</code>      SearchEnv</li><li><code>starts</code>   the set of vertices whose outgoing edges are available</li><li><code>assigned</code> the set of vertices whose incoming edges are already assigned</li><li><code>dist_mtx</code> encodes the cost of each edge v -&gt; vp as <code>dist_mtx[v,vp]</code></li><li><code>pairs</code>    specifies eligible edges</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L1277-L1289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS, AbstractPC_MAPF, N}, Tuple{ISPS, AbstractPC_MAPF, N, SearchEnv}} where N&lt;:ConstraintTreeNode" href="#TaskGraphs.compute_route_plan!-Union{Tuple{N}, Tuple{ISPS, AbstractPC_MAPF, N}, Tuple{ISPS, AbstractPC_MAPF, N, SearchEnv}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.compute_route_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_route_plan!</code></pre><p>Computes all paths specified by the project schedule and updates the solution in the ConstraintTreeNode::node accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L364-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_cost_model" href="#TaskGraphs.construct_cost_model"><code>TaskGraphs.construct_cost_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_cost_model(solver::AStarSC, args...;kwargs...)</code></pre><p>Defines the cost model used by Slack- and Collision-aware A*. This particular setting of cost model is crucial for good performance of A_star, because it encourages depth first search. If we were to replace terms 3-5 with SumOfTravelTime(), we would get worst-case exponentially slow breadth-first search!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_heuristic_model" href="#TaskGraphs.construct_heuristic_model"><code>TaskGraphs.construct_heuristic_model</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_heuristic_model(solver,env_graph;kwargs...)</code></pre><p>Construct the heuristic model to be used by solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_operation" href="#TaskGraphs.construct_operation"><code>TaskGraphs.construct_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_operation(spec::ProjectSpec, station_id, input_ids, output_ids, Δt, id=get_unique_operation_id())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L133-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_partial_project_schedule" href="#TaskGraphs.construct_partial_project_schedule"><code>TaskGraphs.construct_partial_project_schedule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_partial_project_schedule</code></pre><p>Constructs a partial project graph</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L917-L921">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_random_project_spec-Tuple{Int64, Vector{OBJECT_AT}, Vector{OBJECT_AT}}" href="#TaskGraphs.construct_random_project_spec-Tuple{Int64, Vector{OBJECT_AT}, Vector{OBJECT_AT}}"><code>TaskGraphs.construct_random_project_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">construct_random_project_spec(M::Int;max_children=1)

Inputs:
    `M` - number of objects involved in the operation
    `max_parents` - determines the max number of inputs to any operation
    `depth_bias` ∈ [0,1] - hyperparameter for tuning depth.
        If `depth_bias` == 1.0, the project_spec graph will always be depth
        balanced (all paths through the tree will be of the same length).
        For `depth_bias` == 0.0, the graph will be as &quot;strung out&quot; as
        possible.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L235-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_random_task_graphs_problem" href="#TaskGraphs.construct_random_task_graphs_problem"><code>TaskGraphs.construct_random_task_graphs_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`construct_randomd_task_graphs_problem`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L376-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_search_env" href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">construct_search_env(solver,schedule,env,...)</code></pre><p>Constructs a new search env by combining the new <code>schedule</code> with the pre- existing <code>get_route_plan(env)</code>. This involves constructing a new cost function that reflects the new schedule structure. TODO: Carry over information about <code>get_cache(search_env)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L616-L623">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_search_env" href="#TaskGraphs.construct_search_env"><code>TaskGraphs.construct_search_env</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">function construct_search_env(solver, env::SearchEnv, ... )</code></pre><p>Construct a new SearchEnv, with cost<em>model and heuristic</em>model defined by the  solver type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L659-L664">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec, Vector{Int64}, Vector{Int64}, Vector{Int64}, Any}" href="#TaskGraphs.construct_task_graphs_problem-Tuple{ProjectSpec, Vector{Int64}, Vector{Int64}, Vector{Int64}, Any}"><code>TaskGraphs.construct_task_graphs_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`construct_task_graphs_problem`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L161-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}" href="#TaskGraphs.convert_env_graph_to_undirected-Tuple{Any}"><code>TaskGraphs.convert_env_graph_to_undirected</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">It is necessary to convert the env graph to an undirected graph because the
gadget is based on undirected edges. Self-edges also need to be removed, as
these are already accounted for in the gadget.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/milp_formulation.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.default_milp_optimizer-Tuple{}" href="#TaskGraphs.default_milp_optimizer-Tuple{}"><code>TaskGraphs.default_milp_optimizer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_milp_optimizer()</code></pre><p>Returns the black box optimizer to be use when formulating JuMP models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/JuMP_interface.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.default_optimizer_attributes-Tuple{}" href="#TaskGraphs.default_optimizer_attributes-Tuple{}"><code>TaskGraphs.default_optimizer_attributes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_optimizer_attributes()</code></pre><p>Return a dictionary of default optimizer attributes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/JuMP_interface.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.evaluate_path_gap-Tuple{SearchEnv, Any, Any}" href="#TaskGraphs.evaluate_path_gap-Tuple{SearchEnv, Any, Any}"><code>TaskGraphs.evaluate_path_gap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">evaluate_path_gap(search_env::SearchEnv,path,v)</code></pre><p>Returns the gap between a path&#39;s length and it&#39;s expected length (based on times stored in <code>get_cache(env).t0</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L731-L736">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.exclude_solutions!-Tuple{JuMP.Model, Matrix{Int64}}" href="#TaskGraphs.exclude_solutions!-Tuple{JuMP.Model, Matrix{Int64}}"><code>TaskGraphs.exclude_solutions!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">exclude_solutions!(model::JuMP.Model,forbidden_solutions::Vector{Matrix{Int}})</code></pre><p>Adds constraints to model such that the solution may not match any solution contained in forbidden<em>solutions. Assumes that the model contains a variable container called X whose entries are binary and whose dimensions are identical to the dimensions of each solution in forbidden</em>solutions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L159-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule, ProblemSpec, Any}" href="#TaskGraphs.fix_precutoff_nodes!-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.fix_precutoff_nodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fix_precutoff_nodes!(sched::OperatingSchedule,
    problem_spec::ProblemSpec,t)</code></pre><p>Identify all nodes that end before the cutoff time, and change their path spec     so that the route planner will not actually plan a path for them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L156-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.formulate_assignment_problem-Tuple{Any, Any}" href="#TaskGraphs.formulate_assignment_problem-Tuple{Any, Any}"><code>TaskGraphs.formulate_assignment_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulate_assignment_problem(solver,prob;</code></pre><p>Returns an assignment problem instance that can be updated (as opposed to being reconstructed from scratch) on each call to <code>update_assignment_problem!</code> prior to being resolved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L590-L596">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.formulate_big_milp" href="#TaskGraphs.formulate_big_milp"><code>TaskGraphs.formulate_big_milp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">formulate_big_milp</code></pre><p>Formulate a PCTAPF problem as a giant network flow MILP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/milp_formulation.jl#L252-L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.formulate_milp-Tuple{AssignmentMILP, OperatingSchedule, ProblemSpec}" href="#TaskGraphs.formulate_milp-Tuple{AssignmentMILP, OperatingSchedule, ProblemSpec}"><code>TaskGraphs.formulate_milp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">formulate_milp(milp_model::AssignmentMILP,sched,problem_spec;kwargs...)</code></pre><p>Express the TaskGraphs assignment problem as an <code>AssignmentMILP</code> using the JuMP optimization framework.</p><p>Inputs:     milp<em>model::T &lt;: TaskGraphsMILP : a milp model that determines how the         sequential task assignment problem is modeled. Current options are         <code>AssignmentMILP</code>, <code>SparseAdjacencyMILP</code> and <code>GreedyAssignment</code>.     sched::OperatingSchedule : a partial operating schedule, where         some or all assignment edges may be missing.     problem</em>spec::ProblemSpec : encodes the distance matrix and other         information about the problem.</p><p>Keyword Args:     <code>optimizer</code> - a JuMP optimizer (e.g., Gurobi.optimizer)     <code>cost_model=MakeSpan</code> - optimization objective, currently either <code>MakeSpan</code>         or <code>SumOfMakeSpans</code>. Defaults to the cost<em>model associated with         `problem</em>spec<code>Outputs:</code>model::AssignmentMILP` - an instantiated optimization problem</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L304-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.generate_path_spec-Tuple{ProblemSpec, Any}" href="#TaskGraphs.generate_path_spec-Tuple{ProblemSpec, Any}"><code>TaskGraphs.generate_path_spec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">generate_path_spec(spec,node)</code></pre><p>Generates a <code>PathSpec</code> struct that encodes information about the path to be planned for <code>node</code>.</p><p>Arguments:</p><ul><li>spec::ProblemSpec</li><li>node::T &lt;: AbstractPlanningPredicate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L554-L563">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule, Any}" href="#TaskGraphs.get_active_and_fixed_vtxs-Tuple{OperatingSchedule, Any}"><code>TaskGraphs.get_active_and_fixed_vtxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_active_and_fixed_vtxs(sched::OperatingSchedule,t)</code></pre><p>&quot;active&quot; vertices &quot;straddle&quot; the query time t &quot;fixed&quot; vertices finish before the query time t</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L90-L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_assignment_dict-Tuple{Any, Any, Any}" href="#TaskGraphs.get_assignment_dict-Tuple{Any, Any, Any}"><code>TaskGraphs.get_assignment_dict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_assignment_dict(assignment_matrix,N,M)</code></pre><p>Returns dictionary that maps each robot id to a sequence of tasks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L1093-L1097">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule, ObjectID}" href="#TaskGraphs.get_delivery_task_vtxs-Tuple{OperatingSchedule, ObjectID}"><code>TaskGraphs.get_delivery_task_vtxs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_delivery_task_vtxs(sched::OperatingSchedule,o::ObjectID)</code></pre><p>Return all vertices that correspond to the delivery task (<code>COLLECT</code> → <code>CARRY</code> → <code>DEPOSIT</code>) of object <code>o</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L148-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_duration_vector-Tuple{ProjectSpec}" href="#TaskGraphs.get_duration_vector-Tuple{ProjectSpec}"><code>TaskGraphs.get_duration_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_duration_vector(spec::ProjectSpec)</code></pre><p>Return a vector <code>Δt</code> such that <code>Δt[i]</code> is the amount of time that must elapse  before object <code>i</code> can be picked up after its parent operation is performed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_env_snapshot-Tuple{SearchEnv, Any}" href="#TaskGraphs.get_env_snapshot-Tuple{SearchEnv, Any}"><code>TaskGraphs.get_env_snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_env_snapshot(route_plan::S,t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L211-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv, Any}" href="#TaskGraphs.get_next_node_matching_agent_id-Tuple{SearchEnv, Any}"><code>TaskGraphs.get_next_node_matching_agent_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_next_node_matching_agent_id(schedule,cache,agent_id)</code></pre><p>Return the node_id of the active node assigned to an agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L437-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv, Any}" href="#TaskGraphs.get_next_vtx_matching_agent_id-Tuple{SearchEnv, Any}"><code>TaskGraphs.get_next_vtx_matching_agent_id</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_next_vtx_matching_agent_id(schedule,cache,agent_id)</code></pre><p>Return the node_id of the active node assigned to an agent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L418-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}" href="#TaskGraphs.get_node_start_and_end_times-Tuple{OperatingSchedule}"><code>TaskGraphs.get_node_start_and_end_times</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_start_and_end_maps(sched,cache,default=0)</code></pre><p>Return dictionaries mapping each node id in schedule to its start and end time</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L318-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_objective_expr-Tuple{AssignmentMILP, SumOfMakeSpans}" href="#TaskGraphs.get_objective_expr-Tuple{AssignmentMILP, SumOfMakeSpans}"><code>TaskGraphs.get_objective_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_objective_expr</code></pre><p>Helper for setting the objective function for a milp model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L272-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_random_problem_instantiation-Tuple{Int64, Int64, Any, Any, Any}" href="#TaskGraphs.get_random_problem_instantiation-Tuple{Int64, Int64, Any, Any, Any}"><code>TaskGraphs.get_random_problem_instantiation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`get_random_problem_instantiation`

Args:
- `N`: number of robots
- `M`: number of delivery tasks
- `robot_zones`: list of possible start locations for robots
- `pickup_zones`: list of possible start locations for objects
- `dropoff_zones`: list of possible destinations for objects</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L358-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_sF-Tuple{AssignmentMILP}" href="#TaskGraphs.get_sF-Tuple{AssignmentMILP}"><code>TaskGraphs.get_sF</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_sF(milp_model::AssignmentMILP)</code></pre><p>Return an a vector of final object locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L201-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph, Any, Any}" href="#TaskGraphs.get_source_map-Tuple{TaskGraphs.GadgetGraph, Any, Any}"><code>TaskGraphs.get_source_map</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Return a source map such that source_map[v][t] points to the corresponding
vertex in the gadget graph.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/milp_formulation.jl#L60-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule, A}, Tuple{OperatingSchedule, A, Any}} where A&lt;:Union{ActionID, BotID}" href="#TaskGraphs.get_valid_robot_ids-Union{Tuple{A}, Tuple{OperatingSchedule, A}, Tuple{OperatingSchedule, A, Any}} where A&lt;:Union{ActionID, BotID}"><code>TaskGraphs.get_valid_robot_ids</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_valid_robot_ids(sched::OperatingSchedule,node_id::AbstractID)</code></pre><p>Returns vector of all robot ids associated with the schedule node referenced by node_id.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L108-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.handle_disturbance!" href="#TaskGraphs.handle_disturbance!"><code>TaskGraphs.handle_disturbance!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">handle_disturbance!(solver,prob,env,d::DroppedObject,t,env_state=get_env_state(env,t))</code></pre><p>Returns a new <code>SearchEnv</code> with a modified <code>OperatingSchedule</code>. The new schedule replaces the previous delivery task (<code>OBJECT_AT(o,old_x)</code> → <code>COLLECT</code> → <code>CARRY</code> → <code>DEPOSIT</code>) with a new <code>CleanUpBot</code> delivery task (<code>OBJECT_AT(o,new_x)</code> → <code>CUB_COLLECT</code> → <code>CUB_CARRY</code> → <code>CUB_DEPOSIT</code>). It is assumed that the time <code>t</code> corresponds to a moment when the object referred to by <code>d.id</code> is being <code>CARRIED</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.isolate_delivery_task_vtxs" href="#TaskGraphs.isolate_delivery_task_vtxs"><code>TaskGraphs.isolate_delivery_task_vtxs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isolate_delivery_task_vtxs(sched,o,vtxs=get_delivery_task_vtxs(sched,o))</code></pre><p>Returns:</p><ul><li>incoming: a set of all incoming Action ScheduleNodes</li><li>outgoing: a set of all outgoing Action ScheduleNodes</li><li>op: the target Operation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L161-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A, Type{B}}} where {A, B}" href="#TaskGraphs.matches_node_type-Union{Tuple{B}, Tuple{A}, Tuple{A, Type{B}}} where {A, B}"><code>TaskGraphs.matches_node_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matches_node_type(::A,::Type{B}) where {A&lt;:AbstractPlanningPredicate,B}</code></pre><p>Returns true if {A &lt;: B}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_1-Tuple{}" href="#TaskGraphs.pctapf_problem_1-Tuple{}"><code>TaskGraphs.pctapf_problem_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_1</code></pre><p>Optimal MakeSpan = 5 Optimal SumOfMakeSpans = 5</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L128-L133">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_10-Tuple{}" href="#TaskGraphs.pctapf_problem_10-Tuple{}"><code>TaskGraphs.pctapf_problem_10</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_10(;cost_function=MakeSpan(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0,0,0],Δt_deposit=[0,0,0,0,0,0])</code></pre><p>Motivation for backtracking in ISPS The makespan optimal solution is T = 8. However, the optimistic schedule will always prioritize task route planning for tasks 1,2, and 3 before 4. This leads to a double delay that will not be caught without backtracking in ISPS. Hence, the solver will return a solution with T = 9.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L467-L475">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_11-Tuple{}" href="#TaskGraphs.pctapf_problem_11-Tuple{}"><code>TaskGraphs.pctapf_problem_11</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_11</code></pre><p>Requires collaborative transport: Robots 1 and 2 transport object 1 while robot 3 transports object 2. Robot 3 will need to move over to let the other robots pass.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L531-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_12-Tuple{}" href="#TaskGraphs.pctapf_problem_12-Tuple{}"><code>TaskGraphs.pctapf_problem_12</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_12(;</code></pre><p>Robot 1 will plan a path first, but then that path will need to be extended by one time step because robot 2 will get delayed by robot 3, which is on the critical path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L580-L586">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_13-Tuple{}" href="#TaskGraphs.pctapf_problem_13-Tuple{}"><code>TaskGraphs.pctapf_problem_13</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_13</code></pre><p>Same as <code>pctapf_problem_12</code>, except that there is a 4th robot who must collect  object 1 with robot 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L617-L622">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_2-Tuple{}" href="#TaskGraphs.pctapf_problem_2-Tuple{}"><code>TaskGraphs.pctapf_problem_2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_2(;cost_function=SumOfMakeSpans(),verbose=false)</code></pre><p>In this problem robot 1 will first do [1-9-17], then [17-21-35] robot 2 will do [4-12-32]. The key thing is that robot 1 will need to wait until robot 2 is finished before robot 1 can do its second task.</p><p>Optimal paths: Optimal MakeSpan = 8 Optimal SumOfMakeSpans = 8</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L159-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_3-Tuple{}" href="#TaskGraphs.pctapf_problem_3-Tuple{}"><code>TaskGraphs.pctapf_problem_3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_3(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0],Δt_deposit=[0,0,0,0])</code></pre><p>In this problem robot 2 will need to yield to let robot 1 through. First operation:     robot 1 does [2-2-30] Second operation:     robot 1 does [30-30-32]     robot 2 does [5-7-8] Third operation:     robot 2 does [8-12-16]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L200-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_4-Tuple{}" href="#TaskGraphs.pctapf_problem_4-Tuple{}"><code>TaskGraphs.pctapf_problem_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_4(;cost_function=SumOfMakeSpans(),verbose=false)</code></pre><p>In this problem the cost of the task assignment problem is lower than the true cost (which requires that one of the robots is delayed by a single time step) First operation:     robot 1 does [2-2-8]     robot 2 does [4-4-6]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L245-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_5-Tuple{}" href="#TaskGraphs.pctapf_problem_5-Tuple{}"><code>TaskGraphs.pctapf_problem_5</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_5(;cost_function=SumOfMakeSpans(),verbose=false)</code></pre><p>In this problem the robots try to pass through each other in such a way that an edge conflict is generated.</p><p>First operation:     robot 1 does [3-11]     robot 2 does [15-7]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L281-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_6-Tuple{}" href="#TaskGraphs.pctapf_problem_6-Tuple{}"><code>TaskGraphs.pctapf_problem_6</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_6(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=1,Δt_collect=[0,0,0],Δt_deposit=[0,0,0])</code></pre><p>Identical to <code>pctapf_problem_2</code>, but process time is non-zero. In this problem robot 1 will first do [1-5-9], then [9-13-17] robot 2 will do [4-8-32]. The key thing is that robot 1 will need to wait until robot 2 is finished before robot 1 can do its second task</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L317-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_7-Tuple{}" href="#TaskGraphs.pctapf_problem_7-Tuple{}"><code>TaskGraphs.pctapf_problem_7</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_7(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,4,0],Δt_deposit=[0,0,0])</code></pre><p>Robot 2 will have to sit and wait at the pickup station, meaning that robot 1  will have to go around if robot 2 is on the critical path</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L357-L362">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_8-Tuple{}" href="#TaskGraphs.pctapf_problem_8-Tuple{}"><code>TaskGraphs.pctapf_problem_8</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_8(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0,0,0],Δt_deposit=[0,0,0,0])</code></pre><p>Two-headed project. Robot 1 does the first half of the first head, and robot 2 handles the first half of the second head, and then they swap. Optimal MakeSpan = 8 Optimal SumOfMakeSpans = 16</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L389-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.pctapf_problem_9-Tuple{}" href="#TaskGraphs.pctapf_problem_9-Tuple{}"><code>TaskGraphs.pctapf_problem_9</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pctapf_problem_9(;cost_function=SumOfMakeSpans(),verbose=false,Δt_op=0,Δt_collect=[0,0],Δt_deposit=[0,0])</code></pre><p>Project with station-sharing. Station 5 needs to accessed by both robots for  picking up their objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L432-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS, AbstractPC_MAPF, SearchEnv, N}} where N&lt;:ConstraintTreeNode" href="#TaskGraphs.plan_next_path!-Union{Tuple{N}, Tuple{ISPS, AbstractPC_MAPF, SearchEnv, N}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.plan_next_path!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`plan_next_path`</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L314-L316">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC, AbstractPC_MAPF, SearchEnv, N, T, Int64}} where {N&lt;:ConstraintTreeNode, T}" href="#TaskGraphs.plan_path!-Union{Tuple{T}, Tuple{N}, Tuple{AStarSC, AbstractPC_MAPF, SearchEnv, N, T, Int64}} where {N&lt;:ConstraintTreeNode, T}"><code>TaskGraphs.plan_path!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plan_path!

Computes next path specified by the project schedule and updates the
solution in the ConstraintTreeNode::node accordingly.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.plan_route!-Tuple{Any, Any, Any}" href="#TaskGraphs.plan_route!-Tuple{Any, Any, Any}"><code>TaskGraphs.plan_route!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plan_route!</code></pre><p>Compute a route plan that corresponds to the OperatingSchedule. Arguments:</p><ul><li>solver</li><li>schedule</li><li>search_env</li></ul><p>Outputs:</p><ul><li>A <code>SearchEnv</code> the contains a valid solution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L667-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.post_process_replanning_results!-Tuple{Any, Any}" href="#TaskGraphs.post_process_replanning_results!-Tuple{Any, Any}"><code>TaskGraphs.post_process_replanning_results!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">add start_time, completion_time, and makespan for each stage</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/experiments/replanning_experiments.jl#L633-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.preprocess_project_schedule-Tuple{Any}" href="#TaskGraphs.preprocess_project_schedule-Tuple{Any}"><code>TaskGraphs.preprocess_project_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">preprocess_project_schedule(sched)</code></pre><p>Returns information about the eligible and required successors and predecessors of nodes in <code>sched</code></p><p>Arguments:</p><ul><li><code>sched::OperatingSchedule</code></li></ul><p>Outputs:</p><ul><li>missing_successors</li><li>missing_predecessors</li><li>n<em>eligible</em>successors</li><li>n<em>eligible</em>predecessors</li><li>n<em>required</em>successors</li><li>n<em>required</em>predecessors</li><li>upstream_vertices</li><li>non<em>upstream</em>vertices</li></ul><p>TODO: OBJECT<em>AT nodes should always have the properties that `indegree(G,v) == n</em>required<em>predecessors(v) == n</em>eligible<em>predecessors(v)<code></code>outdegree(G,v) == n</em>required<em>successors(v) == n</em>eligible_successors(v)` Not sure if this is currently the case. UPDATE: I believe this has already been     addressed by making each object come from an initial operation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L470-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P, Any}, Tuple{P, Any, Any}} where P&lt;:OperatingSchedule" href="#TaskGraphs.process_schedule-Union{Tuple{P}, Tuple{P, Any}, Tuple{P, Any, Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.process_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">process_schedule(schedule::P) where {P&lt;:OperatingSchedule}</code></pre><p>Compute the optimistic start and end times, along with the slack associated with each vertex in the <code>schedule</code>. Slack for each vertex is represented as a vector in order to handle multi-headed projects.</p><p>Args:</p><ul><li>schedule::OperatingSchedule</li><li>[OPTIONAL] t0::Vector{Int}: default = zeros(Int,nv(schedule))</li><li>[OPTIONAL] tF::Vector{Int}: default = zeros(Int,nv(schedule))</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L985-L996">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule, ProblemSpec, Any}" href="#TaskGraphs.prune_project_schedule-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.prune_project_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`prune_project_schedule`</code></pre><p>Remove all vertices that have already been completed. The idea is to identify all <code>Operation</code>s that are completed before <code>t</code>, remove all nodes upstream of them (except for ROBOT<em>AT nodes), and create new edges between the ROBOT</em>AT nodes and their first GO assignments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L301-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.prune_schedule-Tuple{OperatingSchedule, ProblemSpec, Any}" href="#TaskGraphs.prune_schedule-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.prune_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prune_schedule(sched::OperatingSchedule,
    problem_spec::ProblemSpec,t)

remove nodes that don&#39;t need to be kept around any longer</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.random_pctapf_def-Tuple{GridFactoryEnvironment, Any}" href="#TaskGraphs.random_pctapf_def-Tuple{GridFactoryEnvironment, Any}"><code>TaskGraphs.random_pctapf_def</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instantiate_random_pctapf_def(env,config)</code></pre><p>Instantiate a random <code>PC_TAPF</code> problem based on the parameters of config.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L868-L872">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.random_pctapf_sequence-Tuple{GridFactoryEnvironment, Any}" href="#TaskGraphs.random_pctapf_sequence-Tuple{GridFactoryEnvironment, Any}"><code>TaskGraphs.random_pctapf_sequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">instantiate_random_repeated_pctapf_problem(env,config)</code></pre><p>Instantiate a random <code>RepeatedPC_TAPF</code> problem based on the parameters of config.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/experiments/replanning_experiments.jl#L111-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.regenerate_path_specs!-Tuple{Any, Any}" href="#TaskGraphs.regenerate_path_specs!-Tuple{Any, Any}"><code>TaskGraphs.regenerate_path_specs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">regenerate_path_specs!(solver,env)</code></pre><p>Recompute all paths specs (to account for changes in the env_graphs that will be propagated to the ProblemSpec&#39;s distance function as well.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L275-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replace_in_schedule!" href="#TaskGraphs.replace_in_schedule!"><code>TaskGraphs.replace_in_schedule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">replace_in_schedule!(schedule::OperatingSchedule,path_spec::T,pred,id::ID) where {T&lt;:PathSpec,ID&lt;:AbstractID}</code></pre><p>Replace the <code>ScheduleNode</code> associated with <code>id</code> with the new node <code>pred</code>, and the accompanying <code>PathSpec</code> <code>path_spec</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_graphs_core.jl#L576-L581">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_config_1-Tuple{}" href="#TaskGraphs.replanning_config_1-Tuple{}"><code>TaskGraphs.replanning_config_1</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replanning_config_1</code></pre><p>Returns a vector of config dictionaries, which can be used to generate random problem instances for profiling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/experiments/replanning_experiments.jl#L365-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_problem-NTuple{4, Any}" href="#TaskGraphs.replanning_problem-NTuple{4, Any}"><code>TaskGraphs.replanning_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replanning_problem</code></pre><p>Constructs a replanning problem, consisting of robot initial conditions, an environment, and a sequence of project requests scheduled to arrive in the factory at regular intervals. Args:</p><ul><li><p>r0: list of integers specifying the start locations of the robots</p></li><li><p>defs: a list of tuples, where each tuple is of the form</p><p><code>([start_1=&gt;goal_1, ...], [([inputs],[outputs]),...])</code></p><p>where the <code>start=&gt;goal</code> pairs define the start and end points for each   object to be delivered, and the <code>([inputs],[outputs])</code> pairs define the   objects that go in and out of each operation.</p></li><li><p>env_graph: the environment (presumably a GridFactoryEnvironment)</p></li></ul><p>Outputs:</p><ul><li>requests: a sequence of <code>ProjectRequest</code>s</li><li>problem_spec: a <code>ProblemSpec</code></li><li>robot<em>ICs: Robot initial conditions `ROBOT</em>AT`</li><li>env_graph: the environment</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L701-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_problem_3-Tuple{Any}" href="#TaskGraphs.replanning_problem_3-Tuple{Any}"><code>TaskGraphs.replanning_problem_3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">The robot should do better if it handles the single task in the second
project prior to working on the third task of the first project.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L795-L798">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.replanning_problem_4-Tuple{Any}" href="#TaskGraphs.replanning_problem_4-Tuple{Any}"><code>TaskGraphs.replanning_problem_4</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Just intended to take longer so that the tests pass even if Julia hasn&#39;t
finished warming up yet.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/problem_instances.jl#L826-L829">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.reset_cache!-Tuple{PlanningCache, OperatingSchedule}" href="#TaskGraphs.reset_cache!-Tuple{PlanningCache, OperatingSchedule}"><code>TaskGraphs.reset_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`reset_cache!(cache,sched)`

Resets the cache so that a solution can be repaired (otherwise calling
low_level_search!() will return immediately because the cache says it&#39;s
complete)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L41-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N, Any}} where N&lt;:ConstraintTreeNode" href="#TaskGraphs.reset_route_plan!-Union{Tuple{N}, Tuple{N, Any}} where N&lt;:ConstraintTreeNode"><code>TaskGraphs.reset_route_plan!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Helper to reset the solution in a constraint node between re-runs of ISPS</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L925-L927">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.resources_reserved-Tuple{Any}" href="#TaskGraphs.resources_reserved-Tuple{Any}"><code>TaskGraphs.resources_reserved</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resources_reserved(node)</code></pre><p>Identifies the resources reserved by a particular <code>node</code> for its duration. For example, <code>resources_reserved(node::COLLECT) = AbstractID[get_location_id(node)]</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L97-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.robot_ids_match-Tuple{Any, Any}" href="#TaskGraphs.robot_ids_match-Tuple{Any, Any}"><code>TaskGraphs.robot_ids_match</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">robot_ids_match(node,node2)</code></pre><p>Checks if robot_ids match between the nodes</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.robot_tip_map" href="#TaskGraphs.robot_tip_map"><code>TaskGraphs.robot_tip_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">robot_tip_map(sched::OperatingSchedule)</code></pre><p>Returns a <code>Dict{RobotID,AbstractID}</code> mapping <code>RobotID</code> to the terminal node of the <code>sched</code> corresponding to the robot&#39;s last assigned task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/utils.jl#L139-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.select_next_edges-NTuple{4, Any}" href="#TaskGraphs.select_next_edges-NTuple{4, Any}"><code>TaskGraphs.select_next_edges</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Identifies the nodes <code>v ∈ Ai</code> and <code>v2 ∈ Ao</code> with the shortest distance <code>D[v,v2]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L1207-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.set_default_milp_optimizer!-Tuple{Any}" href="#TaskGraphs.set_default_milp_optimizer!-Tuple{Any}"><code>TaskGraphs.set_default_milp_optimizer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_default_milp_optimizer!(optimizer)</code></pre><p>Set the black box optimizer to be use when formulating JuMP models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/JuMP_interface.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair, Vararg{Any}}" href="#TaskGraphs.set_default_optimizer_attributes!-Tuple{Pair, Vararg{Any}}"><code>TaskGraphs.set_default_optimizer_attributes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">set_default_optimizer_attributes!(vals)</code></pre><p>Set default optimizer attributes. e.g. <code>set_default_optimizer_attributes!(Dict(&quot;PreSolve&quot;=&gt;-1))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/JuMP_interface.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver, Any, Any}" href="#TaskGraphs.solve_assignment_problem!-Tuple{TaskGraphsMILPSolver, Any, Any}"><code>TaskGraphs.solve_assignment_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve_assignment_problem!(solver,model,prob)</code></pre><p>Solve the &quot;assignment problem&quot;–i.e., the relaxation of the full PC-TAPF problem wherein we ignore collisions–using the algorithm encoded by solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L636-L641">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P, P}, Tuple{P, P, Any}} where P&lt;:OperatingSchedule" href="#TaskGraphs.splice_schedules!-Union{Tuple{P}, Tuple{P, P}, Tuple{P, P, Any}} where P&lt;:OperatingSchedule"><code>TaskGraphs.splice_schedules!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">splice_schedules!(sched::P,next_sched::P) where {P&lt;:OperatingSchedule}</code></pre><p>Merge next_sched into sched</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule, ProblemSpec, Any}" href="#TaskGraphs.split_active_vtxs!-Tuple{OperatingSchedule, ProblemSpec, Any}"><code>TaskGraphs.split_active_vtxs!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_active_vtxs!(sched::OperatingSchedule,
    problem_spec::ProblemSpec,t;</code></pre><p>Split all GO nodes that &quot;straddle&quot; the cutoff time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L129-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.split_node" href="#TaskGraphs.split_node"><code>TaskGraphs.split_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">split_node(node::N,x::LocationID)</code></pre><p>Creates two new nodes of type <code>N</code>, where the destination of the first node and the starting location of the second node are both set to <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/planning_predicates.jl#L126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.stitch_disjoint_node_sets!-NTuple{4, Any}" href="#TaskGraphs.stitch_disjoint_node_sets!-NTuple{4, Any}"><code>TaskGraphs.stitch_disjoint_node_sets!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">stitch_disjoint_node_sets!(sched,incoming,outgoing)</code></pre><p>Finds and adds the appropriate edges between two sets of nodes. It is assumed that <code>size(incoming) == size(outgoing)</code>, that each node in <code>incoming</code> has exactly one feasible successor in <code>outgoing</code>, and that each node in <code>outgoing</code> has exactly one feasible predecessor in <code>incoming</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/disturbances.jl#L186-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.tighten_gaps!-Tuple{Any, AbstractPC_MAPF, SearchEnv, ConstraintTreeNode}" href="#TaskGraphs.tighten_gaps!-Tuple{Any, AbstractPC_MAPF, SearchEnv, ConstraintTreeNode}"><code>TaskGraphs.tighten_gaps!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tighten_gaps!(solver, pc_mapf, env::SearchEnv, constraint_node::ConstraintTreeNode)</code></pre><p>If any path ends before it should (based on times stored in <code>get_cache(env)</code>), recomputes the path segment for the final node in that line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L759-L764">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.trim_route_plan-Tuple{Any, Any, Any}" href="#TaskGraphs.trim_route_plan-Tuple{Any, Any, Any}"><code>TaskGraphs.trim_route_plan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">trim_route_plan(search_env, route_plan, T)</code></pre><p>Construct a trimmed route_plan that stops at a certain time step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/replanning.jl#L70-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:TaskGraphsMILP" href="#TaskGraphs.update_assignment_problem!-Union{Tuple{T}, Tuple{Any, T, Any}} where T&lt;:TaskGraphsMILP"><code>TaskGraphs.update_assignment_problem!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_assignment_problem!(solver, assignment_problem)</code></pre><p>A helper method for updating an instance of an assignment problem. In the case     of MILP-based models, this method simply excludes all previous solutions by     adding new constraints on the assignment/adjacency matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L619-L625">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any, SearchEnv, Int64, P}, Tuple{Any, SearchEnv, Int64, P, Any}} where P&lt;:Path" href="#TaskGraphs.update_env!-Union{Tuple{P}, Tuple{Any, SearchEnv, Int64, P}, Tuple{Any, SearchEnv, Int64, P, Any}} where P&lt;:Path"><code>TaskGraphs.update_env!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">`update_env!`

`v` is the vertex id</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L699-L703">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_planning_cache!-Tuple{Any, Any}" href="#TaskGraphs.update_planning_cache!-Tuple{Any, Any}"><code>TaskGraphs.update_planning_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_planning_cache!(solver,env)</code></pre><p>Update cache continually. After a call to this function, the start and end times of all schedule nodes will be updated to reflect the progress of active schedule nodes (i.e., if a robot had not yet completed a GO task, the predicted final time for that task will be updated based on the robot&#39;s current state and distance to the goal). All active nodes that don&#39;t require planning will be automatically marked as complete.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L495-L505">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_planning_cache!-Tuple{Any, SearchEnv, Int64, Path}" href="#TaskGraphs.update_planning_cache!-Tuple{Any, SearchEnv, Int64, Path}"><code>TaskGraphs.update_planning_cache!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_planning_cache!(solver,env,v,path)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/path_planning.jl#L454-L456">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_project_schedule!" href="#TaskGraphs.update_project_schedule!"><code>TaskGraphs.update_project_schedule!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_project_schedule!(solver,milp_model::M,sched,problem_spec,
    adj_matrix) where {M&lt;:TaskGraphsMILP}</code></pre><p>Args:</p><ul><li>milp_model &lt;: TaskGraphsMILP</li><li>sched::OperatingSchedule</li><li>problem_spec::ProblemSpec</li><li>adj<em>matrix : an adjacency</em>matrix or (in the case where   <code>milp_model::AssignmentMILP</code>), an assignment matrix</li></ul><p>Adds all required edges to the schedule graph and modifies all nodes to reflect the appropriate valid IDs (e.g., <code>Action</code> nodes are populated with the correct <code>RobotID</code>s) Returns <code>false</code> if the new edges cause cycles in the project graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L1404-L1419">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_project_schedule!-Tuple{Any, OperatingSchedule, Any, Any}" href="#TaskGraphs.update_project_schedule!-Tuple{Any, OperatingSchedule, Any, Any}"><code>TaskGraphs.update_project_schedule!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">update_project_schedule!</code></pre><p>Args:</p><ul><li>solver</li><li>sched</li><li>adj<em>matrix - adjacency</em>matrix encoding the edges that need to be added to   the project schedule</li></ul><p>Adds all required edges to the project graph and modifies all nodes to reflect the appropriate valid IDs (e.g., <code>Action</code> nodes are populated with the correct <code>RobotID</code>s) Returns <code>false</code> if the new edges cause cycles in the project graph.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/task_assignment_solvers.jl#L1348-L1361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.update_route_plan!" href="#TaskGraphs.update_route_plan!"><code>TaskGraphs.update_route_plan!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">update_route_plan!()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/pc_tapf_solvers.jl#L177-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.warmup" href="#TaskGraphs.warmup"><code>TaskGraphs.warmup</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">warmup(loader::TaskGraphsProblemLoader,solver_config,problem_dir,dummy_path = &quot;dummy_path&quot;)</code></pre><p>Do a small dry run of <code>run_profiling(loader,solver_config,problem_dir)</code> to  ensure that all code is fully compiled before collecting results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/profiling.jl#L237-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TaskGraphs.write_problem" href="#TaskGraphs.write_problem"><code>TaskGraphs.write_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_problem(loader::TaskGraphsProblemLoader,problem_def,prob_path,env_id=&quot;&quot;)</code></pre><p>Write a problem that can later be loaded and solved.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/sisl/TaskGraphs.jl/blob/cb5d1bb9f9cd10fbed7f606b9d82707949a47b5e/src/helpers/profiling.jl#L137-L141">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../library/">« Core Types and Methods</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 20 December 2022 00:49">Tuesday 20 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
